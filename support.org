#+title: Support.org
#+startup: overview align
#+babel: :cache no
#+Options: ^:nil num:nil tags:nil
#+PROPERTY: header-args    :tangle yes

This file contains all the elisp implementing Episteme's customizations.

* bootstrap

The following sections take care of bootstrapping =straight.el= for
package-management and some other concerns before things can get started.

** preamble
#+begin_src emacs-lisp
  ;;; support.el --- episteme customizations  -*- lexical-binding:t -*-
  (setq warning-minimum-level :error)
#+end_src

** straight.el
[[https://github.com/raxod502/straight.el][straight.el]] is an alternative to [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Packages.html][package.el]] with many advantages including the
ability to integrate with [[https://github.com/jwiegley/use-package][use-package]] and installing packages from git or
github.

*** bootstrap
Run the [[https://github.com/raxod502/straight.el#bootstrapping-straightel][straight.el bootstrap]].
#+begin_src emacs-lisp
  (let ((bootstrap-file (concat (getenv "config") "straight/repos/straight.el/bootstrap.el"))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

*** use-package integration
Ensure that =use-package= is [[https://github.com/raxod502/straight.el#integration-with-use-package-1][working with straight.el]]
#+begin_src emacs-lisp
  (setq straight-use-package-by-default t)
  (straight-use-package 'use-package)
  (use-package git) ;; ensure we can install from git sources
#+end_src

** general dependencies

The following package dependencies are used throughout the rest of the
configuration. They provide contemporary APIs for working with various elisp
data structures.

*** core libraries
#+begin_src emacs-lisp
  (require 'cl-lib)
  (require 'color)
  (require 'json)
#+end_src

*** third-party libraries
#+begin_src emacs-lisp
  (use-package f :demand t)          ;; files
  (use-package dash :demand t)       ;; lists
  (use-package ht :demand t)         ;; hash-tables
  (use-package s :demand t)          ;; strings
  (use-package a :demand t)          ;; association lists
  (use-package anaphora :demand t)   ;; anaphora
#+end_src

* helpers

These macros are conveinent shorthands.

** :function
Make non-interactive functions out of forms or a symbol.

e.g. =(:function (message "Hello world.")=
e.g. =(:function foobar)=

#+begin_src emacs-lisp
  (defmacro :function (&rest body)
    (if (->> body length (< 1))
        `(lambda () ,@body)
      (pcase (car body)
        ;; command symbol
        ((and v (pred commandp))
         `(lambda () (call-interactively (quote ,v))))
        ;; function symbol
        ((and v (pred symbolp))
         `(lambda () (,v)))
        ;; quoted command symbol
        ((and v (pred consp) (guard (eq 'quote (car v))) (pred commandp (cadr v)))
         `(lambda () (call-interactively ,v)))
        ;; quoted function symbol
        ((and v (pred consp) (guard (eq 'quote (car v))))
         `(lambda () (,(cadr v))))
        ;; body forms
        (_ `(lambda () ,@body) ))))
#+end_src

** :command
Make interactive commands out of forms or a symbol.

e.g. =(:command (message "Hello world."))=
e.g. =(:command foobar)=

#+begin_src emacs-lisp
  (defmacro :command (&rest body)
    (if (->> body length (< 1))
        `(lambda () (interactive) ,@body)
      (pcase (car body)
        ;; command symbol
        ((and v (pred commandp))
         `(lambda () (interactive) (call-interactively (quote ,v))))
        ;; function symbol
        ((and v (pred symbolp))
         `(lambda () (interactive) (,v)))
        ;; quoted command symbol
        ((and v (pred consp) (guard (eq 'quote (car v))) (pred commandp (cadr v)))
         `(lambda () (interactive) (call-interactively ,v)))
        ;; quoted function symbol
        ((and v (pred consp) (guard (eq 'quote (car v))))
         `(lambda () (interactive) (,(cadr v))))
        ;; body forms
        (_ `(lambda () (interactive) ,@body) ))))
#+end_src

** :hook
Register some forms or a symbol with a hook.

e.g. =(:hook org-mode (message "hello world")=
e.g. (:hook org-mode foobar)

#+begin_src emacs-lisp
  (defmacro :hook (hook-name &rest body)
    "A simple wrapper around `add-hook'"
    (declare (indent defun))
    (let* ((hook-name (format "%s-hook" (symbol-name hook-name)))
           (hook-sym (intern hook-name))
           (first (car body))
           (local (eq :local first))
           (body (if local (cdr body) body))
           (first (car body))
           (body (if (consp first)
                     (if (eq (car first) 'quote)
                         first
                       `(lambda () ,@body))
                   `',first)))
      `(add-hook ',hook-sym ,body nil ,local)))
#+end_src

** :bind
Bind some forms or a symbol to a key.

e.g. =(:bind "C-m" nil (message "Hello world."=
e.g. =(:bind "C-m" org-mode-map (message "Hello world."))=

#+begin_src emacs-lisp
  (defmacro :bind (key mode &rest body)
    (declare (indent defun))
    (let ((body (if (symbolp body) `(,body) body)))
      (if (and (org-not-nil mode) (symbolp mode))
          (if (boundp mode)
              `(define-key ,mode (kbd ,key) ,(eval `(:command ,@body)))
            (let ((mode (intern (format "%s-map" mode)))
                  (body (eval `(:command ,@(cdr body)))))
              `(define-key ,mode (kbd ,key) ,body)))
        `(global-set-key (kbd ,(eval key)) ,(eval `(:command ,@body))))))
#+end_src

** :later
#+begin_src emacs-lisp
  (defmacro :later (&rest body)
    `(:hook episteme/after-load ,@body))
#+end_src

** :after
Defer some forms until the given package is loaded.

e.g. =(:after org (message "Hello world"))=

#+begin_src emacs-lisp
  (defmacro :after (package &rest body)
    "A simple wrapper around `with-eval-after-load'."
    (declare (indent defun))
    `(with-eval-after-load ',package ,@body))
#+end_src

** :push
A wrapper around help:add-to-list.

e.g. =(:push some-list 1 2 3)=

#+begin_src emacs-lisp
  (defmacro :push (sym &rest body)
    (declare (indent defun))
    (if (consp body)
        `(setq ,sym (-snoc ,sym ,@body))
      `(add-to-list ,sym ,body)))
#+end_src

** :push-menu
#+begin_src emacs-lisp
  (defmacro :push-menu (name)
    (let ((sym (intern (format "episteme-menu:%s/body" (symbol-name name)))))
      `(hera-push (quote ,sym))))
  ;; (:push-menu help)
#+end_src

* configuration
** episteme paths
#+begin_src emacs-lisp
  ;; paths
  (setq episteme/home-path (getenv "config"))
  (setq episteme/support-path (concat episteme/home-path "/support"))
  (setq episteme/docs-path (concat episteme/support-path "/docs"))
  (setq episteme/autosaves-path (concat episteme/home-path "/autosaves"))
  (setq episteme/backups-path (concat episteme/home-path "/backups"))
  (setq episteme/journal-path (concat episteme/home-path "/journal"))
  (setq episteme/remotes-path (concat episteme/home-path "/remotes"))

  ;; files
  (setq episteme/user-init-file (concat episteme/home-path "/init.el"))
  (setq episteme/user-config-file (concat episteme/home-path "/config.el"))
  (setq episteme/todo-file (concat episteme/home-path "/todo.org"))
#+end_src

** epicenter paths
#+begin_src emacs-lisp
  ;; paths
  (setq epicenter/remotes-path (concat episteme/home-path "/epicenter"))

  ;; files
  (setq epicenter/remotes-file (concat epicenter/remotes-path "/remotes.json"))
#+end_src
** useSSH
#+begin_src emacs-lisp
(setq episteme/useSSH (getenv useSSH))
#+end_src

** default keybinds
#+begin_src emacs-lisp
  (setq episteme/main-menu-key "C-c x")
  (setq episteme/mode-menu-key "C-c m")
#+end_src

** default settings
#+begin_src emacs-lisp
  (setq episteme/default-remote "episteme")
  (setq episteme/fill-width 120)
  (setq episteme/zoom 1)
#+end_src

** hooks
#+begin_src emacs-lisp
  (defvar episteme/after-load-hook nil
    "Hook called after the custom file is loaded")
#+end_src

* user init.el
#+begin_src emacs-lisp
  ;; create user init.el if it doesn't exist
  (unless (file-exists-p episteme/user-init-file)
    (with-temp-file episteme/user-init-file
      (insert "
  ;; keybind for default menu
  (setq episteme/main-menu-key \"C-c x\")

  ;; keybind for major-mode menu
  (setq episteme/mode-menu-key \"C-c m\")

  ;; defaut zoom level
  (setq episteme/zoom 1)
  ")))

  ;; load the user init.el
  (when (file-exists-p episteme/user-init-file)
      (message "Loading globals from: %s" episteme/user-init-file)
      (load-file episteme/user-init-file))

  ;; update some globals that are calculated from episteme vars
  (setq user-emacs-directory episteme/home-path)
  (setq episteme/current-remote episteme/default-remote)
#+end_src

* keybinds
#+begin_src emacs-lisp
  (:later
    (:bind episteme/main-menu-key nil (hera-start 'episteme-menu:main/body))
    (:bind episteme/mode-menu-key nil episteme:hydra-dwim)
    (:bind "C-x g" nil magit-status))
#+end_src

* third-party packages
** hydra

[[https://github.com/abo-abo/hydra][Hydra]] provides customizable interactive command palettes.

*** pretty-hydra
[[https://github.com/jerrypnz/major-mode-hydra.el#pretty-hydra][Pretty-hydra]] provides a macro that makes it easy to get good looking hydras.

#+begin_src emacs-lisp
  (use-package pretty-hydra
    :demand t
    :straight (pretty-hydra :type git :host github
                            :repo "jerrypnz/major-mode-hydra.el"
                            :files ("pretty-hydra.el")))
#+end_src

*** major-mode-hydra
[[https://github.com/jerrypnz/major-mode-hydra.el][Major-mode-hydra]] associates hydras with major-modes.

#+begin_src emacs-lisp
  (use-package major-mode-hydra
    :straight (major-mode-hydra :type git :host github
                                :repo "jerrypnz/major-mode-hydra.el"
                                :files ("major-mode-hydra.el")))
#+end_src

*** hera
[[https://github.com/dustinlacewell/hera][Hera]] lets hydras form a stack.

#+begin_src emacs-lisp
  (use-package hera
    :demand t
    :straight (hera :type git :host github :repo "dustinlacewell/hera"))
#+end_src

*** :hydra
Macro for defining Hydras.
**** boilerplate
***** inject-hint
#+begin_src emacs-lisp
  (defun :hydra/inject-hint (symbol hint)
    (-let* ((name (symbol-name symbol))
            (hint-symbol (intern (format "%s/hint" name)))
            (format-form (eval hint-symbol))
            (string-cdr (nthcdr 1 format-form))
            (format-string (string-trim (car string-cdr)))
            (amended-string (format "%s\n\n%s" format-string hint)))
      (setcar string-cdr amended-string)))
#+end_src

***** make-head-hint
#+begin_src emacs-lisp
  (defun :hydra/make-head-hint (head default-color)
    (-let (((key _ hint . rest) head))
      (when key
        (-let* (((&plist :color color) rest)
                (color (or color default-color))
                (face (intern (format "hydra-face-%s" color)))
                (propertized-key (propertize key 'face face)))
          (format " [%s]: %s" propertized-key hint)))))
#+end_src

***** make-hint
#+begin_src emacs-lisp
  (defun :hydra/make-hint (heads default-color)
    (string-join
     (cl-loop for head in heads
              for hint = (:hydra/make-head-hint head default-color)
              collect hint) "\n"))
#+end_src

***** clear-hint
#+begin_src emacs-lisp
  (defun :hydra/clear-hint (head)
    (-let* (((key form _ . rest) head))
      `(,key ,form nil ,@rest)))
#+end_src

***** add-exit-head
#+begin_src emacs-lisp
  (defun :hydra/add-exit-head (heads)
    (let ((exit-head '("SPC" (hera-pop) "to exit" :color blue)))
      (append heads `(,exit-head))))
#+end_src

***** add-heads
#+begin_src emacs-lisp
    (defun :hydra/add-heads (columns extra-heads)
      (let* ((cell (nthcdr 1 columns))
             (heads (car cell))
             (extra-heads (mapcar ':hydra/clear-hint extra-heads)))
        (setcar cell (append heads extra-heads))))

#+end_src

**** macro
#+begin_src emacs-lisp
    (defmacro :hydra (name body columns &optional extra-heads)
      (declare (indent defun))
      (-let* (((&plist :color default-color :major-mode mode) body)
              (extra-heads (:hydra/add-exit-head extra-heads))
              (extra-hint (:hydra/make-hint extra-heads default-color))
              (body (plist-put body :hint nil))
              (body-name (format "%s/body" (symbol-name name)))
              (body-symbol (intern body-name))
              (mode-body-name (major-mode-hydra--body-name-for mode))
              (mode-support
               `(when ',mode
                  (defun ,mode-body-name () (interactive) (,body-symbol)))))
        (:hydra/add-heads columns extra-heads)
        (when mode
          (cl-remf body :major-mode))
        `(progn
           (pretty-hydra-define ,name ,body ,columns)
           (:hydra/inject-hint ',name ,extra-hint)
           ,mode-support
           )))
#+end_src

**** tests
#+begin_src emacs-lisp
    ;; (macroexpand-all `(:hydra hydra-test (:color red :major-mode fundamental-mode)
    ;;    ("First"
    ;;     (("a" (message "first - a") "msg a" :color blue)
    ;;      ("b" (message "first - b") "msg b"))
    ;;     "Second"
    ;;     (("c" (message "second - c") "msg c" :color blue)
    ;;      ("d" (message "second - d") "msg d")))))

    ;; (:hydra hydra-test (:color red :major-mode fundamental-mode)
    ;;    ("First"
    ;;     (("a" (message "first - a") "msg a" :color blue)
    ;;      ("b" (message "first - b") "msg b"))
    ;;     "Second"
    ;;     (("c" (message "second - c") "msg c" :color blue)
    ;;      ("d" (message "second - d") "msg d"))))

#+end_src
** treemacs
#+begin_src emacs-lisp
  (use-package treemacs
    :demand t
    :custom
    (treemacs--project-follow-delay 0.5))

  (defun episteme:show-sidebar ()
    (interactive)
    (let ((current-window (get-buffer-window))
          (treemacs--find-user-project-functions
           '((lambda () episteme/current-remote-root))))
      (treemacs-display-current-project-exclusively)
      (select-window current-window)))

  (defun episteme:toggle-sidebar ()
    (interactive)
    (if-let (win (treemacs-get-local-window))
        (progn (treemacs-select-window)
               (kill-buffer-and-window))
      (episteme:show-sidebar)))
#+end_src

** helpful
Alternative to the built-in Emacs help that provides much more contextual
information.

#+begin_src emacs-lisp
  (use-package helpful
      :straight (helpful :type git :host github :repo "Wilfred/helpful")
      :bind (("C-h s" . #'helpful-symbol)
             ("C-h c" . #'helpful-command)
             ("C-h f" . #'helpful-function)
             ("C-h v" . #'helpful-variable)
             ("C-h k" . #'helpful-key)
             ("C-h m" . #'helpful-mode)
             ("C-h C-h" . #'helpful-at-point)))
#+end_src

*** contextual help
**** toggle-context-help
#+begin_src emacs-lisp
  (defun toggle-context-help ()
    "Turn on or off the context help.
  Note that if ON and you hide the help buffer then you need to
  manually reshow it. A double toggle will make it reappear"
    (interactive)
    (with-current-buffer (help-buffer)
      (unless (local-variable-p 'context-help)
        (set (make-local-variable 'context-help) t))
      (if (setq context-help (not context-help))
          (progn
             (if (not (get-buffer-window (help-buffer)))
                 (display-buffer (help-buffer)))))
      (message "Context help %s" (if context-help "ON" "OFF"))))
#+end_src

**** context-help
#+begin_src emacs-lisp
  (defun context-help ()
    "Display function or variable at point in *Help* buffer if visible.
  Default behaviour can be turned off by setting the buffer local
  context-help to false"
    (interactive)
    (let ((rgr-symbol (symbol-at-point))) ; symbol-at-point http://www.emacswiki.org/cgi-bin/wiki/thingatpt%2B.el
      (with-current-buffer (help-buffer)
       (unless (local-variable-p 'context-help)
         (set (make-local-variable 'context-help) t))
       (if (and context-help (get-buffer-window (help-buffer))
           rgr-symbol)
         (if (fboundp  rgr-symbol)
             (describe-function rgr-symbol)
           (if (boundp  rgr-symbol) (describe-variable rgr-symbol)))))))
#+end_src

**** advise symbol eldoc
#+begin_src emacs-lisp
  (defadvice eldoc-print-current-symbol-info
    (around eldoc-show-c-tag activate)
    (cond
          ((eq major-mode 'emacs-lisp-mode) (context-help) ad-do-it)
          ((eq major-mode 'lisp-interaction-mode) (context-help) ad-do-it)
          ((eq major-mode 'apropos-mode) (context-help) ad-do-it)
          (t ad-do-it)))
#+end_src
** dashboard
#+begin_src emacs-lisp
  (use-package dashboard
    :ensure t)
#+end_src

** languages
*** lispy-mode
#+begin_src emacs-lisp
  (use-package lispy
    :init
    (:hook emacs-lisp-mode (lispy-mode 1))
    (:hook lisp-interaction-mode (lispy-mode 1))
    :bind
    (":" . self-insert-command)
    ("[" . lispy-open-square)
    ("]" . lispy-close-square))
#+end_src
*** json-mode
#+begin_src emacs-lisp
  (use-package json-mode
    :straight (json-mode :type git
                         :host github
                         :repo "kiennq/json-mode"
                         :branch "feat/jsonc-mode")
    :config
    (setf auto-mode-alist (assoc-delete-all "\\(?:\\(?:\\.\\(?:b\\(?:\\(?:abel\\|ower\\)rc\\)\\|json\\(?:ld\\)?\\)\\|composer\\.lock\\)\\'\\)"
                                            auto-mode-alist))
    (setf auto-mode-alist (assoc-delete-all "\\.json\\'" auto-mode-alist))
    (:push auto-mode-alist '("\\.json\\'" . jsonc-mode)))
#+end_src

** helm
Menu and selection framework for finding files, switching buffers, running
grep, etc. A number of Episteme features are built ontop of Helm.

#+begin_src emacs-lisp
  (use-package helm
    :config
    (helm-mode 1)
    (require 'helm-config)
    :bind
    ("M-x" . helm-M-x)
    ("C-x C-f" . helm-find-files)
    ("C-x b" . helm-mini)
    ("C-c y" . helm-show-kill-ring)
    ("C-x C-r" . helm-recentf))
#+end_src
*** ace jump
Quickly jump to any candidate with a short letter combo.

#+begin_src emacs-lisp
  (use-package ace-jump-helm-line
    :bind (:map helm-map
                ("C-;" . ace-jump-helm-line)))
#+end_src

*** helm-ag
#+begin_src emacs-lisp
  (use-package helm-ag)
#+end_src

*** helm-descbinds
Use (=C-h b= / =kbd-helm-descbinds=) to inspect current bindings with Helm.

#+begin_src emacs-lisp
  (use-package helm-descbinds
    :commands helm-descbinds
    :config
    (:bind "C-h b" nil helm-descbinds))
#+end_src

*** auto full frame
Make Helm always full height.

#+begin_src emacs-lisp
  (defvar helm-full-frame-threshold 0.75)

  (when window-system
    (defun helm-full-frame-hook ()
    (let ((threshold (* helm-full-frame-threshold (x-display-pixel-height))))
      (setq helm-full-frame (< (frame-height) threshold))))

    (:hook helm-before-initialize 'helm-full-frame-hook))
#+end_src
** magit
The best git frontend there is.

#+begin_src emacs-lisp
  (use-package magit)
#+end_src

** org-mode
A souped up markup with tasking, scheduling and aggregation features.

*** straight.el fixes

Fix some issues with straight.el and org until [[https://github.com/raxod502/straight.el#installing-org-with-straightel][that is resolved]].

**** fix-org-git-version
#+begin_src emacs-lisp
  (defun fix-org-git-version ()
    "The Git version of org-mode.
    Inserted by installing org-mode or when a release is made."
    (require 'git)
    (let ((git-repo (expand-file-name
                     "straight/repos/org/" user-emacs-directory)))
      (string-trim
       (git-run "describe"
                "--match=release\*"
                "--abbrev=6"
                "HEAD"))))
#+end_src

**** fix-org-release
#+begin_src emacs-lisp
  (defun fix-org-release ()
    "The release version of org-mode.
    Inserted by installing org-mode or when a release is made."
    (require 'git)
    (let ((git-repo (expand-file-name
                     "straight/repos/org/" user-emacs-directory)))
      (string-trim
       (string-remove-prefix
        "release_"
        (git-run "describe"
                 "--match=release\*"
                 "--abbrev=0"
                 "HEAD")))))
#+end_src

*** installation
#+begin_src emacs-lisp
  (use-package org
    :config
    ;; these depend on the 'straight.el fixes' above
    (defalias #'org-git-version #'fix-org-git-version)
    (defalias #'org-release #'fix-org-release)
    (require 'org-habit)
    (require 'org-indent)
    (require 'org-capture)
    (require 'org-tempo)
    (add-to-list 'org-modules 'org-habit t))
#+end_src

*** look
**** theme customizations
#+begin_src emacs-lisp
  (when window-system
    (use-package org-beautify-theme
      :after (org)
      :config
      (setq org-fontify-whole-heading-line t)
      (setq org-fontify-quote-and-verse-blocks t)
      (setq org-hide-emphasis-markers t)
      (cl-loop for (face . spec) in
       `((org-document-title .
          ((t (:inherit org-level-1 :height 2.0 :underline nil :box nil))))
         (org-level-1 . ((t (:height 1.5 :box nil))))
         (org-level-2 . ((t (:height 1.25 :box nil))))
         (org-level-3 . ((t (:box nil))))
         (org-level-4 . ((t (:box nil))))
         (org-level-5 . ((t (:box nil))))
         (org-level-6 . ((t (:box nil))))
         (org-level-7 . ((t (:box nil))))
         (org-level-8 . ((t (:box nil))))
         (org-link . ((t (:underline t)))))
       do (face-spec-set face spec))))
#+end_src

**** pretty symbols
Add a hook to set the pretty symbols alist.

#+begin_src emacs-lisp
  (setq episteme/pretty-symbols nil)
  (:hook org-mode
    (setq-local prettify-symbols-alist episteme/pretty-symbols))
#+end_src
**** indent by header level
Hide the heading asterisks. Instead indent headings based on depth.

#+begin_src emacs-lisp
  (:hook org-mode 'org-indent-mode)
#+end_src

**** pretty heading bullets
Use nice unicode bullets instead of the default asterisks.

#+begin_src emacs-lisp
  (use-package org-bullets
    :init
    (:hook org-mode 'org-bullets-mode)
    :config
    (setq org-bullets-bullet-list '("◉" "○" "✸" "•")))
#+end_src

**** pretty priority cookies
Instead of the default =[#A]= and =[#C]= priority cookies, use little unicode arrows to
indicate high and low priority. =[#B]=, which is the same as no priority, is shown as
normal.

#+begin_src emacs-lisp
  (:push episteme/pretty-symbols
    '("[#A]" . "⇑")
    '("[#C]" . "⇓"))
#+end_src

#+begin_src emacs-lisp
  ;; only show priority cookie symbols on headings.
  (defun nougat/org-pretty-compose-p (start end match)
    (if (or (string= match "[#A]") (string= match "[#C]"))
        ;; prettify asterisks in headings
        (org-match-line org-outline-regexp-bol)
      ;; else rely on the default function
      (funcall #'prettify-symbols-default-compose-p start end match)))


  (:hook org-mode (setq-local prettify-symbols-compose-predicate
                              #'nougat/org-pretty-compose-p))
#+end_src

**** pretty heading ellipsis
Show a little arrow for collapsed headings.

#+begin_src emacs-lisp
  (:after org
    (setq org-ellipsis " ▿"))
#+end_src

**** prettify source blocks
#+begin_src emacs-lisp
  (:push episteme/pretty-symbols
    '("#+begin_src" . ">>")
    '("#+end_src" . "·"))
#+end_src
**** dynamic tag position
#+begin_src emacs-lisp
  (defun org-realign-tags ()
    (interactive)
    (setq org-tags-column (- 0 (window-width)))
    (org-align-tags t))

  ;; (:hook window-configuration-change 'org-realign-tags)
#+end_src

*** feel
**** show all headings on startup
#+begin_src emacs-lisp
  (setq org-startup-folded 'content)
#+end_src

**** don't fold blocks on open
#+begin_src emacs-lisp
  (setq org-hide-block-startup nil)
#+end_src

**** resepect content on insert
Don't split existing entries when inserting a new heading.

#+begin_src emacs-lisp
  (setq org-insert-heading-respect-content nil)
#+end_src

**** use helpful for help links
#+begin_src emacs-lisp
  (advice-add 'org-link--open-help :override
              (lambda (path) (helpful-symbol (intern path))))
#+end_src
*** todo keywords
**** boilerplate
***** make-state-model
#+begin_src emacs-lisp
  (defun todo-make-state-model (name key props)
    (append (list :name name :key key) props))
#+end_src
***** parse-state-data
#+begin_src emacs-lisp
  (defun todo-parse-state-data (state-data)
    (-let* (((name second &rest) state-data)
            ((key props) (if (stringp second)
                             (list second (cddr state-data))
                           (list nil (cdr state-data)))))
      (todo-make-state-model name key props)))
#+end_src
***** make-sequence-mode
#+begin_src emacs-lisp
  (defun todo-make-sequence-model (states)
    (mapcar 'todo-parse-state-data states))
#+end_src
***** parse-sequences-data
#+begin_src emacs-lisp
  (defun todo-parse-sequences-data (sequences-data)
    (mapcar 'todo-make-sequence-model sequences-data))
#+end_src
***** todo-keyword-name
#+begin_src emacs-lisp
  (defun todo-keyword-name (name key)
    (if key (format "%s(%s)" name key) name))
#+end_src
***** keyword-name-forstate
#+begin_src emacs-lisp
  (defun todo-keyword-name-for-state (state)
    (todo-keyword-name (plist-get state :name)
                       (plist-get state :key)))
#+end_src
***** is-done-state
#+begin_src emacs-lisp
  (defun todo-is-done-state (state)
    (equal t (plist-get state :done-state)))
#+end_src
***** is-not-done-state
#+begin_src emacs-lisp
  (defun todo-is-not-done-state (state)
    (equal nil (plist-get state :done-state)))
#+end_src
***** org-sequence
#+begin_src emacs-lisp
  (defun todo-org-sequence (states)
    (let ((active (seq-filter 'todo-is-not-done-state states))
          (inactive (seq-filter 'todo-is-done-state states)))
      (append '(sequence)
              (mapcar 'todo-keyword-name-for-state active)
              '("|")
              (mapcar 'todo-keyword-name-for-state inactive))))
#+end_src
***** org-todo-keywords
#+begin_src emacs-lisp
  (defun todo-org-todo-keywords (sequences)
    (mapcar 'todo-org-sequence (todo-parse-sequences-data sequences)))
  ;; (todo-org-todo-keywords todo-keywords)
#+end_src
***** org-todo-keyword-faces
#+begin_src emacs-lisp
  (defun todo-org-todo-keyword-faces (sequences)
    (cl-loop for sequence in (todo-parse-sequences-data sequences)
             append (cl-loop for state in sequence
                             for name = (plist-get state :name)
                             for face = (plist-get state :face)
                             collect (cons name face))))
  ;; (todo-org-todo-keyword-faces todo-keywords)
#+end_src
***** prettify-symbols-alist
#+begin_src emacs-lisp
  (defun todo-prettify-symbols-alist (sequences)
    (cl-loop for sequence in (todo-parse-sequences-data sequences)
             append (cl-loop for state in sequence
                             for name = (plist-get state :name)
                             for icon = (plist-get state :icon)
                             collect (cons name icon))))
  ;; (todo-prettify-symbols-alist todo-keywords)
#+end_src
***** finalize-agenda-for-state
#+begin_src emacs-lisp
  (defun todo-finalize-agenda-for-state (state)
    (-let (((&plist :name :icon :face) state))
      (beginning-of-buffer)
      (while (search-forward name nil 1)
        (let* ((line-props (text-properties-at (point)))
               (line-props (org-plist-delete line-props 'face)))
          (call-interactively 'set-mark-command)
          (search-backward name)
          (call-interactively 'kill-region)
          (let ((symbol-pos (point)))
            (insert icon)
            (beginning-of-line)
            (let ((start (point))
                  (end (progn (end-of-line) (point))))
              (add-text-properties start end line-props)
              (add-face-text-property symbol-pos (+ 1 symbol-pos) face))))))
    (beginning-of-buffer)
    (replace-regexp "[[:space:]]+[=]+" ""))
#+end_src

**** keywords
#+begin_src emacs-lisp
  (setq todo-keywords
        ;; normal workflow
        '((("DOING" "d" :icon "🏃" :face org-doing-face)
           ("TODO" "t" :icon "□ " :face org-todo-face)
           ("DONE" "D" :icon "✓ " :face org-done-face :done-state t))
          ;; auxillary states
          (("SOON" "s" :icon "❗ " :face org-soon-face)
           ("SOMEDAY" "S" :icon "🛌" :face org-doing-face)))
        org-todo-keywords (todo-org-todo-keywords todo-keywords)
        org-todo-keyword-faces (todo-org-todo-keyword-faces todo-keywords))

  (--map (:push episteme/pretty-symbols it)
         (todo-prettify-symbols-alist todo-keywords))
#+end_src

**** org agenda finalization
#+begin_src emacs-lisp
  (setq episteme/todo-sequences-data (todo-parse-sequences-data todo-keywords))
  (:hook org-agenda-finalize
    (--each episteme/todo-sequences-data
      (-each it 'todo-finalize-agenda-for-state)))
#+end_src
**** sorting
#+begin_src emacs-lisp
  (defun episteme:todo-sort (a b)
    (let* ((a-state (get-text-property 0 'todo-state a))
           (b-state (get-text-property 0 'todo-state b))
           (a-index (-elem-index a-state todo-keyword-order))
           (b-index (-elem-index b-state todo-keyword-order)))
      (pcase (- b-index a-index)
        ((and v (guard (< 0 v))) 1)
        ((and v (guard (> 0 v))) -1)
        (default nil))))

  (setq org-agenda-cmp-user-defined 'episteme:todo-sort
        todo-keyword-order '("DOING" "SOON" "TODO" "SOMEDAY" "DONE"))
#+end_src

*** org-babel
**** babel languages
***** ob-csharp
#+begin_src emacs-lisp
  (use-package ob-csharp
    :straight (ob-csharp :type git
                         :host github
                         :repo "thomas-villagers/ob-csharp"
                         :files ("src/ob-csharp.el"))
    :config
    (:push org-babel-load-languages '(csharp . t)))
#+end_src
***** ob-fsharp
#+begin_src emacs-lisp
  (use-package ob-fsharp
    :straight (ob-fsharp :type git
                         :host github
                         :repo "zweifisch/ob-fsharp"
                         :files ("ob-fsharp.el"))
    :config
    (:push org-babel-load-languages '(fsharp . t)))
#+end_src
**** enable languages
#+begin_src emacs-lisp
  (setq org-babel-load-languages
        '((shell . t)
          (emacs-lisp . t)
          (python . t)
          (js . t)
          (csharp . t)
          (fsharp . t)))
#+end_src

**** default header args
#+begin_src emacs-lisp
  (:after org
    (setq org-babel-default-header-args
          '((:session . "none")
            (:results . "replace")
            (:exports . "code")
            (:cache . "no")
            (:noweb . "no")
            (:hlines . "no")
            (:tangle . "no"))))
#+end_src

**** security
Disable prompts for evaluating org-mode links.
#+begin_src emacs-lisp
  (progn
    (setq org-confirm-babel-evaluate nil)
    (setq org-confirm-elisp-link-function nil)
    (setq org-confirm-shell-link-function nil)
    (setq safe-local-variable-values '((org-confirm-elisp-link-function . nil))))
#+end_src
**** install babel handlers
#+begin_src emacs-lisp
  (:hook after-init
    (org-babel-do-load-languages 'org-babel-load-languages
                                 org-babel-load-languages))
#+end_src

*** org-fragtog
Automatically preview LaTex fragments.

#+begin_src emacs-lisp
  (use-package org-fragtog
    :config
    (:hook org-mode 'org-fragtog-mode))
#+end_src

*** helm-org
#+begin_src emacs-lisp
  (use-package helm-org)
#+end_src
*** helm-org-rifle
Quickly search through the current org buffer.

#+begin_src emacs-lisp
  (use-package helm-org-rifle)
#+end_src
*** helm-org-walk
Easily navigate Org files with Helm.
#+begin_src emacs-lisp
  (use-package helm-org-walk
    :straight (helm-org-walk :type git :host github :repo "dustinlacewell/helm-org-walk"))
#+end_src
*** org-ql
Query Org files for elements.
#+begin_src emacs-lisp
  (use-package org-ql)
#+end_src
*** org-ls
Interact with babel codeblocks from elisp.
#+begin_src emacs-lisp
  (use-package org-ls
    :straight (org-ls :type git :host github :repo "dustinlacewell/org-ls"))
#+end_src
*** org-journal
#+begin_src emacs-lisp
  (use-package org-journal
    :config
    (setq org-journal-dir episteme/journal-path)
    (setq org-journal-file-type 'weekly))
#+end_src

*** org-roam
Backlink support
#+begin_src emacs-lisp
  (defun episteme:ensure-org-id ()
    (interactive)
    (when (s-starts-with? episteme/current-remote-root (buffer-file-name))
      (save-excursion
        (beginning-of-buffer)
        (org-id-get-create))))

  (use-package org-roam
    :ensure t
    :init
    (setq org-roam-v2-ack 2)
    :bind (("C-c n l" . org-roam-buffer-toggle)
           ("C-c n f" . org-roam-node-find)
           ("C-c n g" . org-roam-graph)
           ("C-c n i" . org-roam-node-insert)
           ("C-c n c" . org-roam-capture)
           ;; Dailies
           ("C-c n j" . org-roam-dailies-capture-today))
    :config
    (setq org-roam-directory episteme/current-remote-root)

    ;; STOP PREPENDING DATES >:|
    (setq org-roam-capture-templates '(("d" "default" plain "%?" :target
                                        (file+head "${slug}.org" "#+TITLE: ${title}\n")
                                        :unnarrowed t)))
    (setq org-roam-extract-new-file-path "${slug}.org")

    ;; STOP USING "_" instead of "-" >:|
    (cl-defmethod org-roam-node-slug ((node org-roam-node))
      (let ((title (org-roam-node-title node))
            (slug-trim-chars '(;; Combining Diacritical Marks https://www.unicode.org/charts/PDF/U0300.pdf
                               768 ; U+0300 COMBINING GRAVE ACCENT
                               769 ; U+0301 COMBINING ACUTE ACCENT
                               770 ; U+0302 COMBINING CIRCUMFLEX ACCENT
                               771 ; U+0303 COMBINING TILDE
                               772 ; U+0304 COMBINING MACRON
                               774 ; U+0306 COMBINING BREVE
                               775 ; U+0307 COMBINING DOT ABOVE
                               776 ; U+0308 COMBINING DIAERESIS
                               777 ; U+0309 COMBINING HOOK ABOVE
                               778 ; U+030A COMBINING RING ABOVE
                               780 ; U+030C COMBINING CARON
                               795 ; U+031B COMBINING HORN
                               803 ; U+0323 COMBINING DOT BELOW
                               804 ; U+0324 COMBINING DIAERESIS BELOW
                               805 ; U+0325 COMBINING RING BELOW
                               807 ; U+0327 COMBINING CEDILLA
                               813 ; U+032D COMBINING CIRCUMFLEX ACCENT BELOW
                               814 ; U+032E COMBINING BREVE BELOW
                               816 ; U+0330 COMBINING TILDE BELOW
                               817))) ; U+0331 COMBINING MACRON BELOW
        (cl-flet* ((nonspacing-mark-p (char)
                                      (memq char slug-trim-chars))
                   (strip-nonspacing-marks (s)
                                           (ucs-normalize-NFC-string
                                            (apply #'string (seq-remove #'nonspacing-mark-p
                                                                        (ucs-normalize-NFD-string s)))))
                   (cl-replace (title pair)
                               (replace-regexp-in-string (car pair) (cdr pair) title)))
          (let* ((pairs `(("[^[:alnum:][:digit:]]" . "-")
                          ("--*" . "-")
                          ("^-" . "")
                          ("-$" . "")))
                 (slug (-reduce-from #'cl-replace (strip-nonspacing-marks title) pairs)))
            (downcase slug)))))

    ;; If using org-roam-protocol
    (require 'org-roam-protocol)
    (:hook org-mode
     (add-hook 'before-save-hook 'episteme:ensure-org-id nil t)))
#+end_src
** other packages
*** persistent-scratch
#+begin_src emacs-lisp
  (use-package persistent-scratch
    :config
    (persistent-scratch-setup-default)
    (setq persistent-scratch-save-file (concat episteme/home-path "/scratch")
          persistent-scratch-autosave-interval 20))
#+end_src
*** embrace
#+begin_src emacs-lisp
  (use-package embrace
    :config
    (embrace-add-pair (kbd "\;") "`" "`"))
#+end_src

*** htmlize
Allows org codeblocks to be syntax highlighted on html export.

#+begin_src emacs-lisp
  (use-package htmlize)
#+end_src

* emacs settings
** autosaves
Periodically save a copy of open files.

*** autosave every file buffer
#+begin_src emacs-lisp
  (setq auto-save-default t)
#+end_src

*** save every 20 secs or 20 keystrokes
#+begin_src emacs-lisp
  (setq auto-save-timeout 20
        auto-save-interval 20)
#+end_src

*** keep autosaves in a single place
#+begin_src emacs-lisp
  (unless (file-exists-p episteme/autosaves-path)
      (make-directory episteme/autosaves-path))

  (setq auto-save-file-name-transforms
        `((".*" ,episteme/autosaves-path t)))
#+end_src

** backups
Backups are created everytime a buffer is manually saved.

*** backup every save
#+begin_src emacs-lisp
  (use-package backup-each-save
    :config (:hook after-save backup-each-save))
#+end_src

*** keep 10 backups
#+begin_src emacs-lisp
  (setq kept-new-versions 10)
#+end_src

*** delete old backups
#+begin_src emacs-lisp
  (setq delete-old-versions t)
#+end_src

*** copy files to avoid various problems
#+begin_src emacs-lisp
  (setq backup-by-copying t)
#+end_src

*** backup files even if version controlled
#+begin_src emacs-lisp
  (setq vc-make-backup-files t)
#+end_src

*** keep backups in a single place
#+begin_src emacs-lisp
  (unless (file-exists-p episteme/backups-path)
    (make-directory episteme/backups-path))

  (setq backup-directory-alist
        `((".*" . ,episteme/backups-path)))

  (setq make-backup-files t)
#+end_src

** cursor
*** box style
#+begin_src emacs-lisp
  (setq-default cursor-type 'box)
#+end_src

*** blinking
#+begin_src emacs-lisp
  (blink-cursor-mode 1)
#+end_src

** disable
Disable various UI and other features for a more minimal
experience.

*** menubar
#+begin_src emacs-lisp
  (menu-bar-mode -1)
#+end_src

*** toolbar
#+begin_src emacs-lisp
  (tool-bar-mode -1)
#+end_src

*** scrollbar
#+begin_src emacs-lisp
  (scroll-bar-mode -1)
#+end_src

*** startup message
#+begin_src emacs-lisp
  (setq inhibit-startup-message t
        initial-scratch-message nil)
#+end_src

*** customizations file
Disable the customizations file so there's no temptation to use the
customization interface.

#+begin_src emacs-lisp
  (setq custom-file (make-temp-file ""))
#+end_src

** editing
*** use spaces
#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src
*** global visual line wrap
#+begin_src emacs-lisp
  (global-visual-line-mode 1)
#+end_src
*** wrap lines at 79 characters
#+begin_src emacs-lisp
  (setq-default fill-column 79)
#+end_src

*** autowrap in text-mode
#+begin_src emacs-lisp
  ;; (:hook text-mode 'turn-on-auto-fill)
#+end_src

*** ssh for tramp
Default method for transferring files with Tramp.

#+begin_src emacs-lisp
  (setq tramp-default-method "ssh")
#+end_src

** minor-modes
*** whitespace-mode
Visually display trailing whitespace

#+begin_src emacs-lisp
  (use-package whitespace
    :custom
    (whitespace-style
     '(face tabs newline trailing tab-mark space-before-tab space-after-tab))
    :config
    (global-whitespace-mode 1))
#+end_src

*** prettify-symbols-mode
Replace various symbols with nice looking unicode glyphs.

#+begin_src emacs-lisp
  (global-prettify-symbols-mode 1)
#+end_src

*** electric-pair-mode
Automatically insert matching close-brackets for any open bracket.

#+begin_src emacs-lisp
  (electric-pair-mode 1)
#+end_src

*** rainbow-delimeters-mode
Color parenthesis based on their depth, using the golden ratio (because why
not).

#+begin_src emacs-lisp
  (require 'color)
  (defun gen-col-list (length s v &optional hval)
    (cl-flet ( (random-float () (/ (random 10000000000) 10000000000.0))
            (mod-float (f) (- f (ffloor f))) )
      (unless hval
        (setq hval (random-float)))
      (let ((golden-ratio-conjugate (/ (- (sqrt 5) 1) 2))
            (h hval)
            (current length)
            (ret-list '()))
        (while (> current 0)
          (setq ret-list
                (append ret-list
                        (list (apply 'color-rgb-to-hex (color-hsl-to-rgb h s v)))))
          (setq h (mod-float (+ h golden-ratio-conjugate)))
          (setq current (- current 1)))
        ret-list)))

  (defun set-random-rainbow-colors (s l &optional h)
    ;; Output into message buffer in case you get a scheme you REALLY like.
    ;; (message "set-random-rainbow-colors %s" (list s l h))
    (interactive)
    (rainbow-delimiters-mode t)

    ;; Show mismatched braces in bright red.
    (set-face-background 'rainbow-delimiters-unmatched-face "red")

    ;; Rainbow delimiters based on golden ratio
    (let ( (colors (gen-col-list 9 s l h))
           (i 1) )
      (let ( (length (length colors)) )
        ;;(message (concat "i " (number-to-string i) " length " (number-to-string length)))
        (while (<= i length)
          (let ( (rainbow-var-name (concat "rainbow-delimiters-depth-" (number-to-string i) "-face"))
                 (col (nth i colors)) )
            ;; (message (concat rainbow-var-name " => " col))
            (set-face-foreground (intern rainbow-var-name) col))
          (setq i (+ i 1))))))

  (use-package rainbow-delimiters :commands rainbow-delimiters-mode :hook ...
    :init
    (setq rainbow-delimiters-max-face-count 16)
    (set-random-rainbow-colors 0.6 0.7 0.5)
    (:hook prog-mode 'rainbow-delimiters-mode))
#+end_src

*** show-paren-mode
Highlight the matching open or closing bracket.

#+begin_src emacs-lisp
  (require 'paren)
  (show-paren-mode 1)
  (setq show-paren-delay 0)
  (:after xresources
    (set-face-foreground 'show-paren-match (theme-color 'green))
    (set-face-foreground 'show-paren-mismatch "#f00")
    (set-face-attribute 'show-paren-match nil :weight 'extra-bold)
    (set-face-attribute 'show-paren-mismatch nil :weight 'extra-bold))
#+end_src

*** which-key-mode
Show possible followups after pressing a key prefix.

#+begin_src emacs-lisp
  (use-package which-key
    :custom
    ;; sort single chars alphabetically P p Q q
    (which-key-sort-order 'which-key-key-order-alpha)
    (which-key-idle-delay 0.4)
    :config
    (which-key-mode))
#+end_src

*** company-mode
Show popup autocompletion.

#+begin_src emacs-lisp
  (use-package company
    :config
    (global-company-mode))
#+end_src

** shorten prompts
Shorten yes/no prompts to one letter.

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** zoom
Adjust font size in buffers or globally.

#+begin_src emacs-lisp
  (use-package zoom-frm
    :straight (zoom-frm :type git
                        :host github
                        :repo "emacsmirror/zoom-frm")
    :config
    (dotimes (i episteme/zoom) (zoom-frm-in)))
#+end_src

** cache
This speeds up help:unicode-fonts-setup after first run.

#+begin_src emacs-lisp
  (use-package persistent-soft)
#+end_src

** eval depth
Avoid elision (...) in messages.

#+begin_src emacs-lisp
  (setq print-level 100
        print-length 9999
        eval-expression-print-level 100
        eval-expression-print-length 9999)
#+end_src

** debug on error
Show tracebacks when errors happen.

#+begin_src emacs-lisp
  (setq debug-on-error t)
#+end_src

** aesthetics
*** visual fill mode
#+begin_src emacs-lisp
  (use-package visual-fill-column
    :config
    (setq fill-column episteme/fill-width)
    (setq global-visual-fill-column-mode 1))
#+end_src

*** vertical border
Make the border between windows visible.

#+begin_src emacs-lisp
  (set-face-foreground 'vertical-border "gray")
#+end_src

*** blend in the fringes
Hide the default buffer margins.

#+begin_src emacs-lisp
  (set-face-attribute 'fringe nil :background nil)
#+end_src

*** column number
Show column number in addition to line number.

#+begin_src emacs-lisp
  (column-number-mode 1)
#+end_src

*** doom modeline
Use [[https://github.com/seagle0128/doom-modeline][doom-modeline]] to ornament the modeline.

#+begin_src emacs-lisp
  (use-package doom-modeline
    :ensure t
    :config
    (doom-modeline-def-segment current-remote
      "Display current episteme remote"
      (format "[%s]" episteme/current-remote))
    (doom-modeline-def-modeline
      'epi-modeline

      '(bar workspace-name window-number modals matches buffer-info remote-host selection-info)
      '(current-remote objed-state buffer-position major-mode process vcs checker misc-info))
    (doom-modeline-mode 1)
    (setq doom-modeline-height 35)
    (setq doom-modeline-bar-width 5)
    (setq tab-bar-format '(episteme:tab-bar-format))
    :init
    (defun setup-custom-doom-modeline ()
      (doom-modeline-set-modeline 'epi-modeline t)
      (force-mode-line-update))
    (add-hook 'doom-modeline-mode-hook 'setup-custom-doom-modeline))
#+end_src

*** doom theme
#+begin_src emacs-lisp
  (use-package doom-themes
    :ensure t
    :config
    ;; Global settings (defaults)
    (setq doom-themes-enable-bold t     ; if nil, bold is universally disabled
          doom-themes-enable-italic t)  ; if nil, italics is universally disabled
    (load-theme (intern (format "doom-%s" (or (getenv "theme") "laserwave"))) t)

    ;; Enable flashing mode-line on errors
    (doom-themes-visual-bell-config)
    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config))
#+end_src

* core
** api
*** get-support-path
#+begin_src emacs-lisp
  (defun episteme-get-support-path (filename)
    (concat episteme/support-path "/" filename))
#+end_src

*** get-docs-path
#+begin_src emacs-lisp
  (defun episteme-get-docs-path (filename)
    (concat episteme/docs-path "/" filename))
#+end_src

** commands
*** open
#+begin_src emacs-lisp
  (defun episteme:open ()
    (interactive)
    (helm-org-walk '(4)))
#+end_src

*** search
#+begin_src emacs-lisp
  (defun episteme:search ()
    (interactive)
    (helm-org-rifle-directories episteme/current-remote-root))
#+end_src

*** find
#+begin_src emacs-lisp
  (defun episteme:find (&optional path)
    (interactive)
    (let ((file-name
           (completing-read "file: "
                            (directory-files-recursively
                             (or path episteme/current-remote-root) "\.org$"))))
      (find-file file-name)))
#+end_src

*** cleanup
#+begin_src emacs-lisp
  (defun episteme:cleanup ()
    (interactive)
    (mapc 'kill-buffer (--filter (not (buffer-modified-p it)) (buffer-list)))
    (delete-other-windows)
    (episteme:dashboard))
#+end_src

* remotes

#+begin_src emacs-lisp
  (defvar episteme/current-remote "episteme"
    "The currently active knowledge-base.")

  (:later ;; activate the default remote
   (episteme-activate-remote episteme/default-remote))
#+end_src

** api
*** remote-exists?
#+begin_src emacs-lisp
  (defun episteme-remote-exists? (remote)
    (file-exists-p (episteme-get-remote-path remote)))
#+end_src

*** remote-is-local?
#+begin_src emacs-lisp
  (defun episteme-remote-is-local? (remote)
    (let ((default-directory (episteme-get-remote-path remote)))
      (not (file-directory-p ".git"))))
#+end_src

*** remote-is-dirty?
#+begin_src emacs-lisp
  (defun episteme-remote-is-dirty? (remote)
    (let ((default-directory (episteme-get-remote-path remote)))
      (not (string= (shell-command-to-string "git status --porcelain") ""))))
#+end_src

*** get-remote-path
#+begin_src emacs-lisp
  (defun episteme-get-remote-path (remote)
    (expand-file-name remote (expand-file-name "remotes" user-emacs-directory)))
#+end_src

*** get-remote-root
#+begin_src emacs-lisp
  (defun episteme-get-remote-root (remote)
    (let* ((path (episteme-get-remote-path remote))
           (conf-path (f-join path "epi.json"))
           (conf-exists (file-exists-p conf-path)))
      (if conf-exists
          ;; get "root" key from json file
          (let* ((conf (json-read-file conf-path))
                 (root (cdr (assoc 'root conf))))
            (if root
                (concat path "/" root)
              path))
        path)))
#+end_src

*** get-remote-url
#+begin_src emacs-lisp
  (defun episteme-get-remote-url (remote)
    (let ((default-directory (episteme-get-remote-path remote)))
      (s-trim (shell-command-to-string "git config --get remote.origin.url"))))
#+end_src

*** set-remote-url
#+begin_src emacs-lisp
  (defun episteme-set-remote-url (remote url)
    (let ((default-directory (episteme-get-remote-path remote))
          (command (format "git config --replace-all remote.origin.url %s" url)))
      (message "%s" command)
      (shell-command command)))
#+end_src

*** get-remote-paths
#+begin_src emacs-lisp
  (defun episteme-get-remote-paths ()
    (let* ((filter (lambda (it) (not (s-starts-with? "." it))))
           (files (-filter filter (directory-files episteme/remotes-path)))
           (paths (-map 'episteme-get-remote-path files))
           (folders (-filter 'f-directory? paths)))
      folders))
#+end_src

*** get-remote-names
#+begin_src emacs-lisp
  (defun episteme-get-remote-names ()
    (let* ((filter (lambda (it) (not (s-starts-with? "." it))))
           (files (-filter filter (directory-files episteme/remotes-path)))
           (paths (-map 'episteme-get-remote-path files))
           (folders (-filter 'f-directory? paths)))
      files))
#+end_src

*** add-remote
#+begin_src emacs-lisp
    (defun episteme-add-remote (name url)
        (if (episteme-remote-exists? name)
            (message "Remote %s already exists" name)
          (let ((default-directory episteme/remotes-path))
            ;; check url is empty
            (if (string= "" url)
                (progn
                    (make-directory (episteme-get-remote-path name))
                    (message "Local remote %s created" name))
              (progn
                (shell-command (format "git clone %s %s" url name))
                (message "Remote %s added" name))))))
#+end_src

*** remove-remote
#+begin_src emacs-lisp
  (defun episteme-remove-remote (name)
    (let ((path (episteme-get-remote-path name))
          (notify (lambda () (message "Remote %s was permanently deleted." name))))
      (if (f-exists? path)
          ;; confirm that the user wants to remove the remote
          (when (yes-or-no-p (format "Are you sure you want to remove %s?" name))
            ;; check if the remote is dirty
            (when (and (or (episteme-remote-is-local? name) (episteme-remote-is-dirty? name))
                       (yes-or-no-p (format "Remote %s has uncommited changes!  Are you sure you want to remove it?" name)))
              (delete-directory path t)
              (funcall notify))
            (delete-directory path t)
            (funcall notify))
        (message "Remote %s does not exist" name))))
#+end_src

*** update-remote
#+begin_src emacs-lisp
  (defun episteme-update-remote (name)
    (let ((path (episteme-get-remote-path name)))
      (if (f-exists? path)
          (if (episteme-remote-is-local? name)
              (message "Remote %s is local and can't be updated." name)
            (if (episteme-remote-is-dirty? name)
                (message "Remote %s has uncommitted changes. Commit all changes before updating." name)
              ;; pull on `path` with magit
              (let ((default-directory path))
                (magit-pull-from-upstream nil)))
            (message "Updated remote %s." name))
        (message "No remote exists with name %s." name))))
#+end_src

*** remote-status
#+begin_src emacs-lisp
  (defun episteme-remote-status (name)
    (let ((path (episteme-get-remote-path name)))
      (if (f-exists? path)
          (if (episteme-remote-is-local? name)
              (message "Remote %s is local and has no git status.")
            (magit-status path))
        (message "No remote exists with name %s." name))))
#+end_src

*** pick-remote
#+begin_src emacs-lisp
  (defun episteme-pick-remote ()
    (let ((remotes (episteme-get-remote-paths)))
      (if (not remotes)
          (message "No remotes found.")
        (let* ((names (-map 'f-filename remotes))
               (name (helm :sources (helm-build-sync-source "Pick remote"
                                                             :candidates names
                                                             :action (lambda (name) name)))))
            name))))
#+end_src

*** activate-remote
Set episteme/current-remote and episteme/current-remote-root.
#+begin_src emacs-lisp
  (defun episteme-activate-remote (name)
    (setq episteme/current-remote name)
    (let ((path (episteme-get-remote-path name))
          (root (episteme-get-remote-root name)))

      (unless (f-exists? path)
        (error "Current remote does not exist: %s" name))
      (unless (f-exists? root)
        (error "Current remote's root does not exist: %s " root))

      (setq episteme/current-remote-root root)
      (setq org-directory episteme/current-remote-root)
      (setq org-roam-directory episteme/current-remote-root)))
#+end_src

** commands
*** add-remote
Add a remote interactively.
#+begin_src emacs-lisp
  (defun episteme:add-remote ()
    (interactive)
    (let* ((name (read-string "Name: "))
           (url (read-string "URL: ")))
      (episteme-add-remote name url)))
#+end_src

*** remove-remote
Remove a remote interactively.
#+begin_src emacs-lisp
  (defun episteme:remove-remote ()
    (interactive)
    (let* ((name (episteme-pick-remote)))
      (when name
        (episteme-remove-remote name))))
#+end_src

*** update-remote
Update a remote interactively.
#+begin_src emacs-lisp
  (defun episteme:update-remote ()
    (interactive)
    (let* ((name (episteme-pick-remote)))
      (when name
        (episteme-update-remote name))))
#+end_src

*** remote-status
Check a remote interactively.
#+begin_src emacs-lisp
  (defun episteme:remote-status ()
    (interactive)
    (let* ((name (episteme-pick-remote)))
      (when name
        (episteme-remote-status name))))
#+end_src

*** set-remote-url
Set the remote url interactively.
#+begin_src emacs-lisp
  (defun episteme:set-remote-url ()
    (interactive)
    (let* ((name (episteme-pick-remote)))
      (when name
        (let ((url (read-string "URL: ")))
          (episteme-set-remote-url name url)
          (message "Remote url for %s set to %s" name url)))))
#+end_src

*** do-activate-remote
Set episteme/current-remote interactively.
#+begin_src emacs-lisp
  (defun episteme:activate-remote ()
    (interactive)
    (let* ((name (episteme-pick-remote)))
      (when name
        (episteme-activate-remote name))))
#+end_src

* status bar
#+begin_src emacs-lisp
  (:later (episteme-init-status-bar))
#+end_src

** api
*** tab-bar-format
#+begin_src emacs-lisp
  (defun episteme-tab-bar-format ()
    (let* ((remote episteme/current-remote)
           (is-dirty (when (episteme-remote-is-dirty? remote)
                       (propertize "⚠️"
                                   'face 'default
                                   'help-echo "Remote has uncommitted changes.")))
           (is-local (when (episteme-remote-is-local? remote) "🏠️"))
           (icon (or is-dirty is-local "🌐"))
           (str (s-trim (format " %s %s (%s)"
                         icon
                         episteme/current-remote
                         episteme/current-remote-root))))
      `((global menu-item ,str ignore))))
#+end_src

*** init-tab-bar
#+begin_src emacs-lisp
  (defun episteme-init-status-bar ()
    (copy-face 'doom-modeline-bar 'tab-bar)
    (invert-face 'tab-bar)
    (let ((fg (face-attribute 'tab-bar :foreground))
          (bg (face-attribute 'default :background)))
      (set-face-attribute 'tab-bar nil
                          :height 100
                          :foreground fg
                          :background (color-darken-name bg 3)))
    (setq tab-bar-format '(episteme-tab-bar-format))
    (tab-bar-mode 1))
#+end_src

* epicenter
** internal
*** load-remotes
#+begin_src emacs-lisp
  (defun epicenter:load-remotes ()
    (let ((remotes-map (json-read-file epicenter/remotes-file)))
      (mapcar (lambda (remote)
                (let ((name (symbol-name (car remote)))
                      (url (if
                               (symbol-value 'episteme/useSSH)
                               (concat "git@" (cdr (nth 1 remote)) ":" (cdr (nth 2 remote)))
                             (concat "https://" (cdr (nth 1 remote)) "/" (cdr (nth 2 remote)))))
                      (description (cdr (nth 3 remote))))
                  (list name url description)))
                remotes-map)))
#+end_src

*** compare-remote-urls
Check every local remote against epicenter remotes.
Gather a list of remotes whos urls are not the same.
Each result should have the name, localUrl, and remoteUrl.
#+begin_src emacs-lisp
  (defun epicenter:compare-remote-urls ()
    (let* ((remotes (epicenter:load-remotes))
           (remote-names (--map (car it) remotes))
           (local-remotes (episteme-get-remote-names))
           ;; calculate which local-remotes are also in remote-names
           (tracked-remotes (-filter
                             (lambda (local) (--first (string= local (car it)) remotes))
                             local-remotes))

           ;; for each tracked-remote create (name localUrl remoteUrl)
           (target-remotes (-map (lambda (tracked)
                                   (list tracked
                                         (episteme-get-remote-url tracked)
                                         ;; find `remote` with same name, return its url
                                         (nth 1 (-first (lambda (remote) (string= (car remote) tracked)) remotes))))
                                 tracked-remotes))
           ;; filter target-remotes down to those where (not (string= (nth 1) (nth 2)))
           (problem-remotes (--filter
                             (not (string= (nth 1 it) (nth 2 it)))
                             target-remotes))
           )
      problem-remotes))
#+end_src

*** pick-from
#+begin_src emacs-lisp
  (defun epicenter:pick-from (remotes &optional title)
    (helm :sources
          (helm-build-sync-source (or title "Pick a remote")
            :multiline t
            :candidates (mapcar (lambda (remote)
                                  (let ((name (nth 0 remote))
                                        (local-url (nth 1 remote))
                                        (remote-url (nth 2 remote)))
                                    (cons (format "%s:\nLocal:  %s\nRemote: %s" name local-url remote-url)
                                          (list name remote-url))))
                                remotes))
          :action (lambda (remote)
                    (let ((name (nth 0 remote))
                          (remote-url (nth 2 remote)))))))
#+end_src

*** pick-remote
#+begin_src emacs-lisp
  (defun epicenter:pick-remote ()
    (interactive)
    (let ((remotes (epicenter:load-remotes)))
      (helm :sources (helm-build-sync-source "Pick an epicenter remote"
                       :multiline t
                       :candidates (mapcar (lambda (remote)
                                             (let ((name (nth 0 remote))
                                                   (url (nth 1 remote))
                                                   (description (nth 2 remote)))
                                               (cons (format "%s: %s\n  %s" name url description)
                                                     (list name url description))))
                                           remotes)))))
#+end_src

** commands
*** update-list
#+begin_src emacs-lisp
  (defun epicenter-update-list ()
    (interactive)
    (let ((default-directory epicenter/remotes-path))
      (shell-command "git pull")))
#+end_src

*** track-knowledgebase
#+begin_src emacs-lisp
  (defun epicenter-track-knowlegebase ()
    (interactive)
    (let ((remote (epicenter:pick-remote)))
      (if remote
          (let ((name (nth 0 remote))
                (url (nth 1 remote)))

            (episteme-add-remote name url)))))
#+end_src

*** compare-remotes
#+begin_src emacs-lisp
  (defun epicenter-compare-remotes ()
    (interactive)
    (let ((remotes (epicenter:compare-remote-urls)))
      (if remotes
          (let* ((choice (epicenter:pick-from remotes))
                 (name (nth 0 choice))
                 (url (nth 1 choice)))
            (episteme-set-remote-url name url)
            (message "Remote `%s` url set to %s" name url))
        (message "No remote urls out-of-sync."))))
#+end_src

* todos
** commands
*** todo
#+begin_src emacs-lisp
  (defun episteme:todo ()
    (interactive)
    (find-file episteme/todo-file))
#+end_src

* journal
** commands
*** journal
#+begin_src emacs-lisp
  (defun episteme:journal ()
    (interactive)
    (org-journal-new-entry '(4)))
#+end_src

*** new-journal-entry
#+begin_src emacs-lisp
  (defun episteme:new-journal-entry ()
    (interactive)
    (org-journal-new-entry nil))
#+end_src

* devlog
** commands
*** new-devlog-entry
#+begin_src emacs-lisp
    (defun episteme:new-devlog-entry ()
      (interactive)
      (let* ((_org-journal-dir org-journal-dir))
        (setq org-journal-dir (episteme-get-support-path "devlog"))
        (org-journal-new-entry nil)
        (setq org-journal-dir _org-journal-dir)))
#+end_src

* dashboard
#+begin_src emacs-lisp
  (:later
   (setq dashboard-center-content t
         dashboard-banner-logo-title "apoptosis/episteme"
         dashboard-startup-banner
         (concat episteme/support-path "/cain.png")
         dashboard-footer-messages
         '("Co-edification through tinkering, dialectic and reference!")
         dashboard-items '((links . 10)
                           (buttons . 10)
                           (remotes . 10)
                           (recents . 5)))

  (add-to-list 'dashboard-item-generators '(links . episteme--dashboard-links))
  (add-to-list 'dashboard-item-generators '(buttons . episteme--dashboard-buttons))
  (add-to-list 'dashboard-item-generators '(remotes . episteme--dashboard-remotes))
  (dashboard-setup-startup-hook))
#+end_src
** internal
*** align-remotes-by-length
#+begin_src emacs-lisp
  (defun episteme--align-remotes-by-length ()
    (let ((len-item (cdr (assoc 'remotes dashboard-items)))
          (align-length -1)
          (count 0)
          (remotes (episteme-get-remote-names))
          len-list base)
      (setq len-list (length remotes))
      (while (and (< count len-item) (< count len-list))
        (setq base (nth count remotes)
              align-length (max align-length (length (dashboard-f-filename base))))
        (cl-incf count))
      align-length))
#+end_src

*** dashboard-remotes-format
#+begin_src emacs-lisp
(defun episteme--dashboard-remotes-format ()
  (let* ((len-align (episteme--align-remotes-by-length))
         (new-fmt (dashboard--generate-align-format
                   dashboard-recentf-item-format len-align)))
    new-fmt))
#+end_src

*** dashboard-insert-section-list
#+begin_src emacs-lisp
(defmacro episteme--dashboard-insert-section-list (section-name list action &rest rest)
  "Insert into SECTION-NAME a LIST of items, expanding ACTION and passing REST to widget creation."
  `(when (car ,list)
     (insert "\n")
     (mapc
      (lambda (el)
        (let ((tag ,@rest))
          (insert "  ")
          (when (and (display-graphic-p)
                     dashboard-set-file-icons
                     (or (fboundp 'all-the-icons-icon-for-dir)
                         (require 'all-the-icons nil 'noerror)))
            (let* ((path (car (last (split-string ,@rest " - "))))
                   (icon (if (and (not (file-remote-p path))
                                  (file-directory-p path))
                             (all-the-icons-icon-for-dir path nil "")
                           (cond
                            ((or (string-equal ,section-name "Agenda for today:")
                                 (string-equal ,section-name "Agenda for the coming week:"))
                             (all-the-icons-octicon "primitive-dot" :height 1.0 :v-adjust 0.01))
                            ((file-remote-p path)
                             (all-the-icons-octicon "radio-tower" :height 1.0 :v-adjust 0.01))
                            (t (all-the-icons-icon-for-file (file-name-nondirectory path)
                                                            :v-adjust -0.05))))))
              (setq tag (concat icon " " ,@rest))))

          (widget-create 'item
                         :tag tag
                         :action ,action
                         :button-face 'dashboard-items-face
                         :mouse-face 'highlight
                         :button-prefix ""
                         :button-suffix ""
                         :format "%[%t%]")))
      ,list)))
#+end_src

*** dashboard-insert-section
#+begin_src emacs-lisp
(defmacro episteme--dashboard-insert-section (section-name list list-size shortcut action &rest widget-params)
  "Add a section with SECTION-NAME and LIST of LIST-SIZE items to the dashboard.
SHORTCUT is the keyboard shortcut used to access the section.
ACTION is theaction taken when the user activates the widget button.
WIDGET-PARAMS are passed to the \"widget-create\" function."
  `(progn
     (dashboard-insert-heading ,section-name
                               (if (and ,list ,shortcut dashboard-show-shortcuts) ,shortcut))
     (if ,list
         (when (and (episteme--dashboard-insert-section-list
                     ,section-name
                     (dashboard-subseq ,list ,list-size)
                     ,action
                     ,@widget-params)
                    ,shortcut)
           (dashboard-insert-shortcut ,shortcut ,section-name))
       (insert (propertize "\n    --- No items ---" 'face 'dashboard-no-items-face)))))
#+end_src

*** dashboard-links
#+begin_src emacs-lisp
  (defun episteme--dashboard-links (list-size)
    (let* ((fmt (episteme--dashboard-remotes-format))
           (remotes (episteme-get-remote-names))
           (items (list (list "github" "https://github.com/apoptosis/episteme")
                        (list "discord" "https://discord.gg/3uPNVyQ5kr")
                        (list "report issue" "https://github.com/apoptosis/episteme/issues/new")))
           (keys (mapcar 'car items)))
      (episteme--dashboard-insert-section
       "web links" keys 5 "l"
       `(lambda (&rest ignore) (browse-url-xdg-open (cadr (assoc ,el (quote ,items)))))
       (format "[%s]" el))))
#+end_src

*** dashboard-buttons
#+begin_src emacs-lisp
  (defun episteme--dashboard-buttons (list-size)
    (let* ((fmt (episteme--dashboard-remotes-format))
           (remotes (episteme-get-remote-names))
           (items (list (cons "main menu" '((lambda () (episteme-menu:main/body))))
                        (cons "init.el" '((lambda () (find-file episteme/user-init-file))))
                        (cons "config.el" '((lambda () (find-file episteme/user-config-file))))
                        (cons "todo" '((lambda () (episteme:todo))))
                        (cons "journal" '((lambda () (episteme:journal))))
                        (cons "epicenter" '((lambda () (epicenter-track-knowlegebase))))
                        (cons "user guide" '((lambda () (find-file (concat episteme/support-path "/docs/user-guide.org")))))))
           (keys (mapcar 'car items)))
      (episteme--dashboard-insert-section
       "common actions" keys list-size "m"
       `(lambda (&rest ignore) (funcall (cadr (assoc ,el (quote ,items)))))
       (format "[%s]" el))))
#+end_src

*** dashboard-remotes
#+begin_src emacs-lisp
(defun episteme--dashboard-remotes (list-size)
  (let ((fmt (episteme--dashboard-remotes-format))
        (remotes (episteme-get-remote-names)))
    (dashboard-insert-section
     "knowledge bases" remotes list-size "k"
     `(lambda (&rest ignore) (message "@@ %s" ,el))
     (format fmt el (episteme-get-remote-url el)))
    ))
#+end_src

** commands
#+begin_src emacs-lisp
(defun episteme:dashboard ()
  "Jump to the dashboard buffer, if doesn't exists create one."
  (interactive)
  (switch-to-buffer dashboard-buffer-name)
  (dashboard-mode)
  (dashboard-insert-startupify-lists)
  (dashboard-refresh-buffer)
  (beginning-of-buffer)
  (search-forward "episteme"))
#+end_src

* main menu
** help
Many of the Emacs help facilities at your fingertips!

#+begin_src emacs-lisp

  (:hydra episteme-menu:help (:color blue)
    ("Describe"
     (("c" describe-function "function")
      ("p" describe-package "package")
      ("m" describe-mode "mode")
      ("v" describe-variable "variable"))
     "Keys"
     (("k" describe-key "key")
      ("K" describe-key-briefly "brief key")
      ("w" where-is "where-is")
      ("b" helm-descbinds "bindings"))
     "Search"
     (("a" helm-apropos "apropos")
      ("d" apropos-documentation "documentation")
      ("s" info-lookup-symbol "symbol info"))
     "Docs"
     (("i" info "info")
      ("n" helm-man-woman "man")
      ("h" helm-dash "dash"))
     "View"
     (("e" view-echo-area-messages "echo area")
      ("l" view-lossage "lossage")
      ("c" describe-coding-system "encoding")
      ("I" describe-input-method "input method")
      ("C" describe-char "char at point"))))
#+end_src

** mark
#+begin_src emacs-lisp
  (defun unpop-to-mark-command ()
    "Unpop off mark ring. Does nothing if mark ring is empty."
    (when mark-ring
      (setq mark-ring (cons (copy-marker (mark-marker)) mark-ring))
      (set-marker (mark-marker) (car (last mark-ring)) (current-buffer))
      (when (null (mark t)) (ding))
      (setq mark-ring (nbutlast mark-ring))
      (goto-char (marker-position (car (last mark-ring))))))

  (defun push-mark ()
    (interactive)
    (set-mark-command nil)
    (set-mark-command nil))

  (:hydra episteme-menu:mark (:color pink)
    ("Mark"
     (("m" push-mark "mark here")
      ("p" (lambda () (interactive) (set-mark-command '(4))) "previous")
      ("n" (lambda () (interactive) (unpop-to-mark-command)) "next")
      ("c" (lambda () (interactive) (setq mark-ring nil)) "clear"))))
#+end_src

** registers
#+begin_src emacs-lisp
  (:hydra episteme-menu:registers (:color pink)
    ("Point"
     (("r" point-to-register "save point")
      ("j" jump-to-register "jump")
      ("v" view-register "view all"))
     "Text"
     (("c" copy-to-register "copy region")
      ("C" copy-rectangle-to-register "copy rect")
      ("i" insert-register "insert")
      ("p" prepend-to-register "prepend")
      ("a" append-to-register "append"))
     "Macros"
     (("m" kmacro-to-register "store")
      ("e" jump-to-register "execute"))))

#+end_src

** windows
#+begin_src emacs-lisp
  (use-package ace-window)
  (winner-mode 1)

  (:hydra episteme-menu:windows (:color red)
    ("Jump"
     (("h" windmove-left "left")
      ("l" windmove-right "right")
      ("k" windmove-up "up")
      ("j" windmove-down "down")
      ("a" ace-select-window "ace"))
     "Split"
     (("q" split-window-right "left")
      ("r" (progn (split-window-right) (call-interactively 'other-window)) "right")
      ("e" split-window-below "up")
      ("w" (progn (split-window-below) (call-interactively 'other-window)) "down"))
     "Do"
     (("d" delete-window "delete")
      ("o" delete-other-windows "delete others")
      ("u" winner-undo "undo")
      ("R" winner-redo "redo")
      ("t" nougat-hydra-toggle-window "toggle"))))
#+end_src

** zoom
#+begin_src emacs-lisp
  (:hydra episteme-menu:zoom (:color red)
    ("Buffer"
     (("i" text-scale-increase "in")
      ("o" text-scale-decrease "out"))
     "Frame"
     (("I" zoom-frm-in "in")
      ("O" zoom-frm-out "out")
      ("r" toggle-zoom-frame "reset" :color blue))))
#+end_src

** remotes
#+begin_src emacs-lisp
    (:hydra episteme-menu:remotes (:color blue)
      ("Knowledge-bases  "
       (("l" (call-interactively (lambda () (interactive) (episteme-pick-remote))) "list")
        ("a" (lambda () (interactive) (episteme:activate-remote)) "activate")
        ("n" episteme:add-remote "new")
        ("u" episteme:update-remote "update")
        ("r" episteme:remove-remote "remove")
        ("g" episteme:remote-status "git status")
        ("s" episteme:set-remote-url "set url"))
       "Epicenter"
       (("U" (epicenter-update-list) "update epicenter")
        ("i" (epicenter-track-knowlegebase) "install community kb"))))
#+end_src

** dev-tools
#+begin_src emacs-lisp
  (:hydra episteme-menu:dev-tools (:color blue)
    ("Open"
     (("s" (find-file (episteme-get-support-path "support.org")) "support.org")
      ("d" (find-file (episteme-get-docs-path "developer-guide.org")) "dev docs")
      ("j" (find-file (episteme-get-docs-path "devlog.org")) "devlog")
      ("J" (episteme:new-devlog-entry) "new devlog entry"))
     "Git"
     (("g" (magit-status episteme/support-path) "magit")
      ("p" (let ((default-directory episteme/support-path)) (magit-pull)) "pull")
      ("R" (magit-reset-hard)))))
#+end_src

** main
#+begin_src emacs-lisp
  (:hydra episteme-menu:main (:color blue)
    ("Open"
     (("!" (episteme:cleanup) "dashboard")
      ("o" (episteme:open) "open")
      ("s" (episteme:search) "search")
      ("a" (episteme:find) "all files")
      ("t" (episteme:todo) "todo")
      ("j" (episteme:journal) "journal")
      ("J" (episteme:new-journal-entry) "new journal entry")
      ("k" (:push-menu remotes) "knowledge-bases"))
     "Emacs"
     (("h" (:push-menu help) "help")
      ("m" (:push-menu mark) "mark")
      ("w" (:push-menu windows) "windows")
      ("z" (:push-menu zoom) "zoom")
      ("r" (:push-menu registers) "registers")
      (";" embrace-commander "parens / quotes"))
     "Bookmarks"
     (("S" episteme:toggle-sidebar "sidebar" :color red)
      ("D" (episteme:find (concat episteme/support-path "/docs")) "docs")
      ("C" (find-file (concat episteme/support-path "/docs/cheatsheet.org")) "cheatsheet")
      ("U" (find-file (concat episteme/support-path "/docs/user-guide.org")) "user guide")
      ("I" (find-file (concat episteme/support-path "/README.org")) "readme"))
     "Misc"
     (("." (:push-menu dev-tools) "dev tools"))))
#+end_src

* mode menus
** commands
*** hydra-dwim
Open hydra for current major mode if one exists, otherwise the default hydra.
#+begin_src emacs-lisp
  (defun episteme:hydra-dwim ()
    (interactive)
    (let* ((mode major-mode)
          (orig-mode mode))
      (catch 'done
        (while mode
          (let ((hydra (major-mode-hydra--body-name-for mode)))
            (when (fboundp hydra)
              (hera-start hydra)
              (throw 'done t)))
          (setq mode (get mode 'derived-mode-parent)))
        (hera-start 'episteme-menu:main/body))))
#+end_src
** hydra-elisp
#+begin_src emacs-lisp
  (:hydra episteme-hydra-elisp (:color blue :major-mode emacs-lisp-mode)
    ("Execute"
     (("d" eval-defun "defun")
      ("b" eval-current-buffer "buffer")
      ("r" eval-region "region"))
     "Debug"
     (("D" edebug-defun "defun")
      ("a" edebug-all-defs "all definitions" :color red)
      ("A" edebug-all-forms "all forms" :color red)
      ("x" macrostep-expand "expand macro"))))
#+end_src

** hydra-org
*** hydra-org-goto-first-sibling
#+begin_src emacs-lisp
  (defun hydra-org-goto-first-sibling () (interactive)
         (org-backward-heading-same-level 99999999))
#+end_src

*** hydra-org-goto-last-sibling
#+begin_src emacs-lisp
  (defun hydra-org-goto-last-sibling () (interactive)
         (org-forward-heading-same-level 99999999))
#+end_src

*** hydra-org-parent-level
#+begin_src emacs-lisp
  (defun hydra-org-parent-level ()
    (interactive)
    (let ((o-point (point)))
      (if (save-excursion
            (beginning-of-line)
            (looking-at org-heading-regexp))
          (progn
            (call-interactively 'outline-up-heading)
            (org-cycle-internal-local))
        (progn
          (call-interactively 'org-previous-visible-heading)
          (org-cycle-internal-local)))
      (when (and (/= o-point (point))
                 org-tidy-p)
        (call-interactively 'hydra-org-tidy))))

 #+end_src

*** hydra-org-child-level
#+begin_src emacs-lisp
  (defun hydra-org-child-level ()
    (interactive)
    (org-show-entry)
    (org-show-children)
    (when (not (org-goto-first-child))
      (when (save-excursion
              (beginning-of-line)
              (looking-at org-heading-regexp))
        (next-line))))
#+end_src

*** hydra-org
 #+begin_src emacs-lisp
   (:hydra episteme-hydra-org (:color amaranth :major-mode org-mode)
     ("Shift"
      (
       ("H" org-promote-subtree "promote")
       ("L" org-demote-subtree "demote")
       ("J" org-move-subtree-down "down")
       ("K" org-move-subtree-up "up")
       )

      "Travel"
      (
       ("h" hydra-org-parent-level "to parent")
       ("l" hydra-org-child-level "to child")
       ("j" org-forward-heading-same-level "forward")
       ("k" org-backward-heading-same-level "backward")
       ("a" hydra-org-goto-first-sibling "first sibling")
       ("e" hydra-org-goto-last-sibling "last sibling")
       )

      "Perform"
      (
       ("t" (org-babel-tangle) "tangle" :color blue)
       ("e" (org-html-export-to-html) "export" :color blue)
       ("b" helm-org-in-buffer-headings "browse")
       ("r" (lambda () (interactive)
              (helm-org-rifle-current-buffer)
              (org-cycle)
              (org-cycle))
        "rifle")
       ("w" helm-org-walk "walk")
       ("v" avy-org-goto-heading-timer "avy")
       ("L" org-toggle-link-display "toggle links")
       ("i" (org-id-get-create) "check id")
       )
      ))
#+end_src

* user config.el
This should remain at the end of this file.
#+begin_src emacs-lisp
  (unless (file-exists-p episteme/user-config-file)
    (with-temp-file episteme/user-config-file
      (insert ";; this is your custom configuration for episteme,
  ;; you can manage it with orgmode by un-commenting
  ;; the following:
  ;;
  ;; (org-babel-load-file
  ;;  (expand-file-name
  ;;  \"README.org\"
  ;;  episteme/home-path))

  (provide 'config)
  ;;;config.el ends here")))

  (when (file-exists-p episteme/user-config-file)
      (message "Loading user config from: %s" episteme/user-config-file)
      (load-file episteme/user-config-file))
#+end_src

#+begin_src emacs-lisp
  (run-hooks 'episteme/after-load-hook)
  (episteme:dashboard)
#+end_src
