#+title: Support.org
#+startup: overview align
#+babel: :cache no
#+Options: ^:nil num:nil tags:nil
#+PROPERTY: header-args    :tangle yes

This file contains all the elisp implementing Episteme's customizations.

* preamble
#+begin_src emacs-lisp
  ;;; support.el --- episteme customizations  -*- lexical-binding:t -*-
  (setq warning-minimum-level :error)
#+end_src
** episteme paths
#+begin_src emacs-lisp
  ;; paths
  (setq episteme/home (getenv "config"))
  (setq episteme/support (concat episteme/home "/support"))
  (setq episteme/user-init-file (concat episteme/home "/init.el"))
  (setq episteme/config (concat episteme/home "/config.el"))
  (setq episteme/org (concat episteme/home "/remotes/apoptosis/org"))
  (setq episteme/autosaves (concat episteme/home "/autosaves"))
  (setq episteme/backups (concat episteme/home "/backups"))
  (setq episteme/journal (concat episteme/home "/journal"))
  (setq episteme/todo-file (concat episteme/home "/todo.org"))
  (setq episteme/remotes-path (concat episteme/home "/remotes"))
#+end_src

** epicenter paths
#+begin_src emacs-lisp
  (setq epicenter/remotes-path (concat episteme/home "/epicenter"))
  (setq epicenter/remotes-file (concat epicenter/remotes-path "/remotes.json"))
#+end_src

** default keybinds
#+begin_src emacs-lisp
  (setq episteme/main-menu-key "C-c x")
  (setq episteme/mode-menu-key "C-c m")
#+end_src

** default settings
#+begin_src emacs-lisp
  (setq episteme/default-remote "episteme")
  (setq episteme/fill-width 120)
  (setq episteme/zoom 1)
#+end_src
** hooks
#+begin_src emacs-lisp
  (defvar episteme-after-load-hook nil
    "Hook called after the custom file is loaded")
#+end_src

** user init.el
#+begin_src emacs-lisp
  ;; create if it doesn't exist
  (unless (file-exists-p episteme/user-init-file)
    (with-temp-file episteme/user-init-file
      (insert "
  ;; keybind for default menu
  (setq episteme/main-menu-key \"C-c x\")

  ;; keybind for major-mode menu
  (setq episteme/mode-menu-key \"C-c m\")

  ;; defaut zoom level
  (setq episteme/zoom 1)
  ")))

  ;; load the user init.el
  (when (file-exists-p episteme/user-init-file)
      (message "Loading globals from: %s" episteme/user-init-file)
      (load-file episteme/user-init-file))

  ;; update some globals that are calculated from epi vars
  (setq user-emacs-directory episteme/home)
  (setq episteme/current-remote episteme/default-remote)
#+end_src
* bootstrap

The following sections take care of bootstrapping =straight.el= for
package-management and some other concerns before things can get started.

** lexical binding

This line controls how the elisp scoping works in the rest of the file. Lexical
binding is explained in the Emacs documentation.

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

** straight.el
[[https://github.com/raxod502/straight.el][straight.el]] is an alternative to [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Packages.html][package.el]] with many advantages including the
ability to integrate with [[https://github.com/jwiegley/use-package][use-package]] and installing packages from git or
github.

*** bootstrap
Run the [[https://github.com/raxod502/straight.el#bootstrapping-straightel][straight.el bootstrap]].
#+begin_src emacs-lisp
  (let ((bootstrap-file (concat user-emacs-directory "/straight/repos/straight.el/bootstrap.el"))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

*** use-package integration
Ensure that =use-package= is [[https://github.com/raxod502/straight.el#integration-with-use-package-1][working with straight.el]]
#+begin_src emacs-lisp
  (setq straight-use-package-by-default t)
  (straight-use-package 'use-package)
  (use-package git) ;; ensure we can install from git sources
#+end_src

** general dependencies

The following package dependencies are used throughout the rest of the
configuration. They provide contemporary APIs for working with various elisp
data structures.

#+begin_src emacs-lisp
  (require 'cl-lib)
  (require 'color)
  (require 'json)
  (use-package f :demand t)          ;; files
  (use-package dash :demand t)       ;; lists
  (use-package ht :demand t)         ;; hash-tables
  (use-package s :demand t)          ;; strings
  (use-package a :demand t)          ;; association lists
  (use-package anaphora :demand t)   ;; anaphora
#+end_src

* helpers
These macros are conveinent shorthands.

** :function
Make non-interactive functions out of forms or a symbol.

e.g. =(:function (message "Hello world.")=
e.g. =(:function foobar)=

#+begin_src emacs-lisp
  (defmacro :function (&rest body)
    (if (->> body length (< 1))
        `(lambda () ,@body)
      (pcase (car body)
        ;; command symbol
        ((and v (pred commandp))
         `(lambda () (call-interactively (quote ,v))))
        ;; function symbol
        ((and v (pred symbolp))
         `(lambda () (,v)))
        ;; quoted command symbol
        ((and v (pred consp) (guard (eq 'quote (car v))) (pred commandp (cadr v)))
         `(lambda () (call-interactively ,v)))
        ;; quoted function symbol
        ((and v (pred consp) (guard (eq 'quote (car v))))
         `(lambda () (,(cadr v))))
        ;; body forms
        (_ `(lambda () ,@body) ))))
#+end_src

** :command
Make interactive commands out of forms or a symbol.

e.g. =(:command (message "Hello world."))=
e.g. =(:command foobar)=

#+begin_src emacs-lisp
  (defmacro :command (&rest body)
    (if (->> body length (< 1))
        `(lambda () (interactive) ,@body)
      (pcase (car body)
        ;; command symbol
        ((and v (pred commandp))
         `(lambda () (interactive) (call-interactively (quote ,v))))
        ;; function symbol
        ((and v (pred symbolp))
         `(lambda () (interactive) (,v)))
        ;; quoted command symbol
        ((and v (pred consp) (guard (eq 'quote (car v))) (pred commandp (cadr v)))
         `(lambda () (interactive) (call-interactively ,v)))
        ;; quoted function symbol
        ((and v (pred consp) (guard (eq 'quote (car v))))
         `(lambda () (interactive) (,(cadr v))))
        ;; body forms
        (_ `(lambda () (interactive) ,@body) ))))
#+end_src

** :after
Defer some forms until the given package is loaded.

e.g. =(:after org (message "Hello world"))=

#+begin_src emacs-lisp
  (defmacro :after (package &rest body)
    "A simple wrapper around `with-eval-after-load'."
    (declare (indent defun))
    `(with-eval-after-load ',package ,@body))
#+end_src

** :hook
Register some forms or a symbol with a hook.

e.g. =(:hook org-mode (message "hello world")=
e.g. (:hook org-mode foobar)

#+begin_src emacs-lisp
  (defmacro :hook (hook-name &rest body)
    "A simple wrapper around `add-hook'"
    (declare (indent defun))
    (let* ((hook-name (format "%s-hook" (symbol-name hook-name)))
           (hook-sym (intern hook-name))
           (first (car body))
           (local (eq :local first))
           (body (if local (cdr body) body))
           (first (car body))
           (body (if (consp first)
                     (if (eq (car first) 'quote)
                         first
                       `(lambda () ,@body))
                   `',first)))
      `(add-hook ',hook-sym ,body nil ,local)))
#+end_src

** :push
A wrapper around help:add-to-list.

e.g. =(:push some-list 1 2 3)=

#+begin_src emacs-lisp
  (defmacro :push (sym &rest body)
    (declare (indent defun))
    (if (consp body)
        `(setq ,sym (-snoc ,sym ,@body))
      `(add-to-list ,sym ,body)))
#+end_src

** :bind
Bind some forms or a symbol to a key.

e.g. =(:bind "C-m" nil (message "Hello world."=
e.g. =(:bind "C-m" org-mode-map (message "Hello world."))=

#+begin_src emacs-lisp
  (defmacro :bind (key mode &rest body)
    (declare (indent defun))
    (let ((body (if (symbolp body) `(,body) body)))
      (if (and (org-not-nil mode) (symbolp mode))
          (if (boundp mode)
              `(define-key ,mode (kbd ,key) ,(eval `(:command ,@body)))
            (let ((mode (intern (format "%s-map" mode)))
                  (body (eval `(:command ,@(cdr body)))))
              `(define-key ,mode (kbd ,key) ,body)))
        `(global-set-key (kbd ,(eval key)) ,(eval `(:command ,@body))))))
#+end_src

* epicenter
** load-remotes
#+begin_src emacs-lisp
  (defun epicenter:load-remotes ()
    (let ((remotes-map (json-read-file epicenter/remotes-file)))
      (mapcar (lambda (remote)
                (let ((name (symbol-name (car remote)))
                      (url (cdr (nth 1 remote)))
                      (description (cdr (nth 2 remote))))
                  (list name url description)))
                remotes-map)))
#+end_src
** update-remotes
#+begin_src emacs-lisp
  (defun epicenter:update-remotes ()
    (let ((default-directory epicenter/remotes-path))
      (shell-command "git pull")))
#+end_src

** compare-remotes
Check every local remote against epicenter remotes.
Gather a list of remotes whos urls are not the same.
Each result should have the name, localUrl, and remoteUrl.
#+begin_src emacs-lisp
  (defun epicenter:compare-remotes ()
    (let* ((remotes (epicenter:load-remotes))
           (remote-names (--map (car it) remotes))
           (local-remotes (episteme:get-remote-names))
           ;; calculate which local-remotes are also in remote-names
           (tracked-remotes (-filter
                             (lambda (local) (--first (string= local (car it)) remotes))
                             local-remotes))

           ;; for each tracked-remote create (name localUrl remoteUrl)
           (target-remotes (-map (lambda (tracked)
                                   (list tracked
                                         (episteme:get-remote-url tracked)
                                         ;; find `remote` with same name, return its url
                                         (nth 1 (-first (lambda (remote) (string= (car remote) tracked)) remotes))))
                                 tracked-remotes))
           ;; filter target-remotes down to those where (not (string= (nth 1) (nth 2)))
           (problem-remotes (--filter
                             (not (string= (nth 1 it) (nth 2 it)))
                             target-remotes))
           )
      problem-remotes))
#+end_src

** pick
#+begin_src emacs-lisp
  (defun epicenter:pick-from (remotes &optional title)
    (helm :sources
          (helm-build-sync-source (or title "Pick a remote")
            :multiline t
            :candidates (mapcar (lambda (remote)
                                  (let ((name (nth 0 remote))
                                        (local-url (nth 1 remote))
                                        (remote-url (nth 2 remote)))
                                    (cons (format "%s:\nLocal:  %s\nRemote: %s" name local-url remote-url)
                                          (list name remote-url))))
                                remotes))
          :action (lambda (remote)
                    (let ((name (nth 0 remote))
                          (remote-url (nth 2 remote)))))))
#+end_src
** pick-remote
#+begin_src emacs-lisp
  (defun epicenter:pick-remote ()
    (interactive)
    (let ((remotes (epicenter:load-remotes)))
      (helm :sources (helm-build-sync-source "Pick an epicenter remote"
                       :multiline t
                       :candidates (mapcar (lambda (remote)
                                             (let ((name (nth 0 remote))
                                                   (url (nth 1 remote))
                                                   (description (nth 2 remote)))
                                               (cons (format "%s: %s\n  %s" name url description)
                                                     (list name url description))))
                                           remotes)))))
#+end_src

** do-track-remote
#+begin_src emacs-lisp
  (defun epicenter:do-track-remote ()
    (interactive)
    (let ((remote (epicenter:pick-remote)))
      (if remote
          (let ((name (nth 0 remote))
                (url (nth 1 remote)))

            (episteme:add-remote name url)))))
#+end_src
** do-compare-remotes
Call compare-remotes to get a list of divergent remotes.
For each problem remote, ask the user if they want to update the local remote.
If so, call set-remote-url on it.
#+begin_src emacs-lisp
  (defun epicenter:do-compare-remotes ()
    (interactive)
    (let ((remotes (epicenter:compare-remotes)))
      (if remotes
          (let* ((choice (epicenter:pick-from remotes))
                 (name (nth 0 choice))
                 (url (nth 1 choice)))
            (episteme:set-remote-url name url)
            (message "Remote `%s` url set to %s" name url))
        (message "No remote urls out-of-sync."))))
#+end_src
* remotes
** remote-exists?
#+begin_src emacs-lisp
  (defun episteme:remote-exists? (remote)
    (file-exists-p (episteme:get-remote-path remote)))
#+end_src
** remote-is-local?
#+begin_src emacs-lisp
  (defun episteme:remote-is-local? (remote)
    (let ((default-directory (episteme:get-remote-path remote)))
      (not (file-directory-p ".git"))))
#+end_src
** remote-is-dirty?
#+begin_src emacs-lisp
  (defun episteme:remote-is-dirty? (remote)
    (let ((default-directory (episteme:get-remote-path remote)))
      (not (string= (shell-command-to-string "git status --porcelain") ""))))
#+end_src
** get-remote-path
#+begin_src emacs-lisp
  (defun episteme:get-remote-path (remote)
    (expand-file-name remote (expand-file-name "remotes" user-emacs-directory)))
#+end_src
** get-remote-root
#+begin_src emacs-lisp
  (defun episteme:get-remote-root (remote)
    (let* ((path (episteme:get-remote-path remote))
           (conf-path (f-join path "epi.json"))
           (conf-exists (file-exists-p conf-path)))
      (if conf-exists
          ;; get "root" key from json file
          (let* ((conf (json-read-file conf-path))
                 (root (cdr (assoc 'root conf))))
            (if root
                (concat path "/" root)
              path))
        path)))
#+end_src
** get-remote-url
#+begin_src emacs-lisp
  (defun episteme:get-remote-url (remote)
    (let ((default-directory (episteme:get-remote-path remote)))
      (s-trim (shell-command-to-string "git config --get remote.origin.url"))))
#+end_src
** set-remote-url
#+begin_src emacs-lisp
  (defun episteme:set-remote-url (remote url)
    (let ((default-directory (episteme:get-remote-path remote))
          (command (format "git config --replace-all remote.origin.url %s" url)))
      (message "%s" command)
      (shell-command command)))
#+end_src
** get-remote-paths
#+begin_src emacs-lisp
  (defun episteme:get-remote-paths ()
    (let* ((filter (lambda (it) (not (s-starts-with? "." it))))
           (files (-filter filter (directory-files episteme/remotes-path)))
           (paths (-map 'episteme:get-remote-path files))
           (folders (-filter 'f-directory? paths)))
      folders))
#+end_src
** get-remote-names
#+begin_src emacs-lisp
  (defun episteme:get-remote-names ()
    (let* ((filter (lambda (it) (not (s-starts-with? "." it))))
           (files (-filter filter (directory-files episteme/remotes-path)))
           (paths (-map 'episteme:get-remote-path files))
           (folders (-filter 'f-directory? paths)))
      files))
#+end_src

** add-remote
#+begin_src emacs-lisp
    (defun episteme:add-remote (name url)
        (if (episteme:remote-exists? name)
            (message "Remote %s already exists" name)
          (let ((default-directory episteme/remotes-path))
            ;; check url is empty
            (if (string= "" url)
                (progn
                    (make-directory (episteme:get-remote-path name))
                    (message "Local remote %s created" name))
              (progn
                (shell-command (format "git clone %s" url))
                (message "Remote %s added" name))))))
#+end_src
** remove-remote
#+begin_src emacs-lisp
  (defun episteme:remove-remote (name)
    (let ((path (episteme:get-remote-path name))
          (notify (lambda () (message "Remote %s was permanently deleted." name))))
      (if (f-exists? path)
          ;; confirm that the user wants to remove the remote
          (when (yes-or-no-p (format "Are you sure you want to remove %s?" name))
            ;; check if the remote is dirty
            (when (and (or (episteme:remote-is-local? name) (episteme:remote-is-dirty? name))
                       (yes-or-no-p (format "Remote %s has uncommited changes!  Are you sure you want to remove it?" name)))
              (delete-directory path t)
              (funcall notify))
            (delete-directory path t)
            (funcall notify))
        (message "Remote %s does not exist" name))))
#+end_src
** update-remote
#+begin_src emacs-lisp
  (defun episteme:update-remote (name)
    (let ((path (episteme:get-remote-path name)))
      (if (f-exists? path)
          (if (episteme:remote-is-local? name)
              (message "Remote %s is local and can't be updated." name)
            (if (episteme:remote-is-dirty? name)
                (message "Remote %s has uncommitted changes. Commit all changes before updating." name)
              ;; pull on `path` with magit
              (let ((default-directory path))
                (magit-pull-from-upstream nil)))
            (message "Updated remote %s." name))
        (message "No remote exists with name %s." name))))
#+end_src
** remote-status
#+begin_src emacs-lisp
  (defun episteme:remote-status (name)
    (let ((path (episteme:get-remote-path name)))
      (if (f-exists? path)
          (if (episteme:remote-is-local? name)
              (message "Remote %s is local and has no git status.")
            (magit-status path))
        (message "No remote exists with name %s." name))))
#+end_src
** pick-remote
#+begin_src emacs-lisp
  (defun episteme:pick-remote ()
    (let ((remotes (episteme:get-remote-paths)))
      (if (not remotes)
          (message "No remotes found.")
        (let* ((names (-map 'f-filename remotes))
               (name (helm :sources (helm-build-sync-source "Pick remote"
                                                             :candidates names
                                                             :action (lambda (name) name)))))
            name))))
#+end_src
** init-remotes
#+begin_src emacs-lisp
  (defun episteme:init-remotes ()
      (let ((path (episteme:get-remote-path episteme/current-remote))
	    (root (episteme:get-remote-root episteme/current-remote)))
	(unless (f-exists? path)
	  (error "Current remote %s does not exist." episteme/current-remote))
	(unless (f-exists? root)
	  (error "Current remote's root does not exist: %s " root))

	(setq episteme/current-remote-root root)
	(setq org-directory episteme/current-remote-root)
	(setq org-roam-directory episteme/current-remote-root)))
  (episteme:init-remotes)
#+end_src
** activate-remote
Set episteme/current-remote and episteme/current-remote-root.
#+begin_src emacs-lisp
  (defun episteme:activate-remote(name)
    (setq episteme/current-remote name)
    (episteme:init-remotes))
#+end_src
** do-add-remote
Add a remote interactively.
#+begin_src emacs-lisp
  (defun episteme:do-add-remote ()
    (interactive)
    (let* ((name (read-string "Name: "))
           (url (read-string "URL: ")))
      (episteme:add-remote name url)))
#+end_src
** do-remove-remote
Remove a remote interactively.
#+begin_src emacs-lisp
  (defun episteme:do-remove-remote ()
    (interactive)
    (let* ((name (episteme:pick-remote)))
      (when name
        (episteme:remove-remote name))))
#+end_src
** do-update-remote
Update a remote interactively.
#+begin_src emacs-lisp
  (defun episteme:do-update-remote ()
    (interactive)
    (let* ((name (episteme:pick-remote)))
      (when name
        (episteme:update-remote name))))
#+end_src
** do-remote-status
Check a remote interactively.
#+begin_src emacs-lisp
  (defun episteme:do-remote-status ()
    (interactive)
    (let* ((name (episteme:pick-remote)))
      (when name
        (episteme:remote-status name))))
#+end_src
** do-set-remote-url
Set the remote url interactively.
#+begin_src emacs-lisp
  (defun episteme:do-set-remote-url ()
    (interactive)
    (let* ((name (episteme:pick-remote)))
      (when name
        (let ((url (read-string "URL: ")))
          (episteme:set-remote-url name url)
          (message "Remote url for %s set to %s" name url)))))
#+end_src
** do-activate-remote
Set episteme/current-remote interactively.
#+begin_src emacs-lisp
  (defun episteme:do-activate-remote ()
    (interactive)
    (let* ((name (episteme:pick-remote)))
      (when name
        (episteme:activate-remote name))))
#+end_src
** tab-bar support
#+begin_src emacs-lisp
  (defun episteme:tab-bar-format ()
    (let* ((remote episteme/current-remote)
           (is-dirty (when (episteme:remote-is-dirty? remote)
                       (propertize "âš ï¸"
                                   'face 'default
                                   'help-echo "Remote has uncommitted changes.")))
           (is-local (when (episteme:remote-is-local? remote) "ðŸ ï¸"))
           (icon (or is-dirty is-local "ðŸŒ"))
           (str (s-trim (format " %s %s (%s)"
                         icon
                         episteme/current-remote
                         episteme/current-remote-root))))
      `((global menu-item ,str ignore))))

  (defun episteme:init-tab-bar ()
    (copy-face 'doom-modeline-bar 'tab-bar)
    (invert-face 'tab-bar)
    (let ((fg (face-attribute 'tab-bar :foreground))
          (bg (face-attribute 'default :background)))
      (set-face-attribute 'tab-bar nil
                          :height 100
                          :foreground fg
                          :background (color-darken-name bg 3)))
    (setq tab-bar-format '(episteme:tab-bar-format))
    (tab-bar-mode 1))

  (progn
    (add-hook 'emacs-startup-hook 'episteme:init-tab-bar))
#+end_src
* keybinds
#+begin_src emacs-lisp
  (defun episteme/bind-keys ()
    (:bind episteme/main-menu-key nil (hera-start 'episteme-hydra-default/body))
    (:bind episteme/mode-menu-key nil episteme:hydra-dwim)
    (:bind "C-x g" nil magit-status))
#+end_src

* dashboard
** lib
*** align-remotes-by-length
#+begin_src emacs-lisp
  (defun episteme:align-remotes-by-length ()
    (let ((len-item (cdr (assoc 'remotes dashboard-items)))
          (align-length -1)
          (count 0)
          (remotes (episteme:get-remote-names))
          len-list base)
      (setq len-list (length remotes))
      (while (and (< count len-item) (< count len-list))
        (setq base (nth count remotes)
              align-length (max align-length (length (dashboard-f-filename base))))
        (cl-incf count))
      align-length))
#+end_src

*** dashboard-remotes-format
#+begin_src emacs-lisp
(defun episteme:dashboard-remotes-format ()
  (let* ((len-align (episteme:align-remotes-by-length))
         (new-fmt (dashboard--generate-align-format
                   dashboard-recentf-item-format len-align)))
    new-fmt))
#+end_src

*** dashboard-insert-section-list
#+begin_src emacs-lisp
(defmacro episteme:dashboard-insert-section-list (section-name list action &rest rest)
  "Insert into SECTION-NAME a LIST of items, expanding ACTION and passing REST to widget creation."
  `(when (car ,list)
     (insert "\n")
     (mapc
      (lambda (el)
        (let ((tag ,@rest))
          (insert "  ")
          (when (and (display-graphic-p)
                     dashboard-set-file-icons
                     (or (fboundp 'all-the-icons-icon-for-dir)
                         (require 'all-the-icons nil 'noerror)))
            (let* ((path (car (last (split-string ,@rest " - "))))
                   (icon (if (and (not (file-remote-p path))
                                  (file-directory-p path))
                             (all-the-icons-icon-for-dir path nil "")
                           (cond
                            ((or (string-equal ,section-name "Agenda for today:")
                                 (string-equal ,section-name "Agenda for the coming week:"))
                             (all-the-icons-octicon "primitive-dot" :height 1.0 :v-adjust 0.01))
                            ((file-remote-p path)
                             (all-the-icons-octicon "radio-tower" :height 1.0 :v-adjust 0.01))
                            (t (all-the-icons-icon-for-file (file-name-nondirectory path)
                                                            :v-adjust -0.05))))))
              (setq tag (concat icon " " ,@rest))))

          (widget-create 'item
                         :tag tag
                         :action ,action
                         :button-face 'dashboard-items-face
                         :mouse-face 'highlight
                         :button-prefix ""
                         :button-suffix ""
                         :format "%[%t%]")))
      ,list)))
#+end_src

*** dashboard-insert-section
#+begin_src emacs-lisp
(defmacro episteme:dashboard-insert-section (section-name list list-size shortcut action &rest widget-params)
  "Add a section with SECTION-NAME and LIST of LIST-SIZE items to the dashboard.
SHORTCUT is the keyboard shortcut used to access the section.
ACTION is theaction taken when the user activates the widget button.
WIDGET-PARAMS are passed to the \"widget-create\" function."
  `(progn
     (dashboard-insert-heading ,section-name
                               (if (and ,list ,shortcut dashboard-show-shortcuts) ,shortcut))
     (if ,list
         (when (and (episteme:dashboard-insert-section-list
                     ,section-name
                     (dashboard-subseq ,list ,list-size)
                     ,action
                     ,@widget-params)
                    ,shortcut)
           (dashboard-insert-shortcut ,shortcut ,section-name))
       (insert (propertize "\n    --- No items ---" 'face 'dashboard-no-items-face)))))
#+end_src

*** dashboard-links
#+begin_src emacs-lisp
(defun episteme:dashboard-links (list-size)
  (let* ((fmt (episteme:dashboard-remotes-format))
         (remotes (episteme:get-remote-names))
         (items (list (list "github" "https://github.com/apoptosis/episteme")
                      (list "discord" "https://discord.gg/3uPNVyQ5kr")
                      (list "report issue" "https://github.com/apoptosis/episteme/issues/new")))
         (keys (mapcar 'car items)))
    (episteme:dashboard-insert-section
     "web links" keys 5 "l"
     `(lambda (&rest ignore) (browse-url-xdg-open (cadr (assoc ,el (quote ,items)))))
     (format "[%s]" el))))
#+end_src

*** dashboard-buttons
#+begin_src emacs-lisp
(defun episteme:dashboard-buttons (list-size)
  (let* ((fmt (episteme:dashboard-remotes-format))
         (remotes (episteme:get-remote-names))
         (items (list (cons "main menu" '((lambda () (episteme-hydra-default/body))))
                      (cons "todo" '((lambda () (episteme:todo))))
                      (cons "journal" '((lambda () (episteme:journal))))
                      (cons "epicenter" '((lambda () (epicenter:do-track-remote))))
                      (cons "user guide" '((lambda () (find-file (concat episteme/support "/docs/user-guide.org")))))))
         (keys (mapcar 'car items)))
    (episteme:dashboard-insert-section
     "common actions" keys 5 "m"
     `(lambda (&rest ignore) (funcall (cadr (assoc ,el (quote ,items)))))
     (format "[%s]" el))))
#+end_src

*** dashboard-remotes
#+begin_src emacs-lisp
(defun episteme:dashboard-remotes (list-size)
  (let ((fmt (episteme:dashboard-remotes-format))
        (remotes (episteme:get-remote-names)))
    (dashboard-insert-section
     "knowledge bases" remotes 5 "k"
     `(lambda (&rest ignore) (message "@@ %s" ,el))
     (format fmt el (episteme:get-remote-url el)))
    ))
#+end_src

** dashboard
#+begin_src emacs-lisp
(defun episteme:dashboard ()
  "Jump to the dashboard buffer, if doesn't exists create one."
  (interactive)
  (switch-to-buffer dashboard-buffer-name)
  (dashboard-mode)
  (dashboard-insert-startupify-lists)
  (dashboard-refresh-buffer)
  (beginning-of-buffer)
  (search-forward "apoptosis/episteme"))
#+end_src

** use-package
#+begin_src emacs-lisp
(use-package dashboard
  :ensure t
  :config
  (setq dashboard-banner-logo-title "apoptosis/episteme")
  (setq dashboard-startup-banner (concat episteme/support "/cain.png"))
  (setq dashboard-footer-messages
        '("Co-edification through tinkering, dialectic and reference!"))
  (setq dashboard-center-content t)
  (add-to-list 'dashboard-item-generators '(links . episteme:dashboard-links))
  (add-to-list 'dashboard-item-generators '(buttons . episteme:dashboard-buttons))
  (add-to-list 'dashboard-item-generators '(remotes . episteme:dashboard-remotes))
  (setq dashboard-items '((links . 10)
                          (buttons . 10) (remotes . 10) (recents . 5)))
  (dashboard-setup-startup-hook))
#+end_src

* aesthetics
** visual fill mode
#+begin_src emacs-lisp
  (use-package visual-fill-column
    :config
    (setq fill-column episteme/fill-width)
    (setq global-visual-fill-column-mode 1))
#+end_src
** vertical border
Make the border between windows visible.

#+begin_src emacs-lisp
  (set-face-foreground 'vertical-border "gray")
#+end_src

** blend in the fringes
Hide the default buffer margins.

#+begin_src emacs-lisp
  (set-face-attribute 'fringe nil :background nil)
#+end_src

** column number
Show column number in addition to line number.

#+begin_src emacs-lisp
  (column-number-mode 1)
#+end_src

** doom modeline
Use [[https://github.com/seagle0128/doom-modeline][doom-modeline]] to ornament the modeline.

#+begin_src emacs-lisp
  (use-package doom-modeline
    :ensure t
    :config
    (doom-modeline-def-segment current-remote
      "Display current episteme remote"
      (format "[%s]" episteme/current-remote))
    (doom-modeline-def-modeline
      'epi-modeline

      '(bar workspace-name window-number modals matches buffer-info remote-host selection-info)
      '(current-remote objed-state buffer-position major-mode process vcs checker misc-info))
    (doom-modeline-mode 1)
    (setq doom-modeline-height 35)
    (setq doom-modeline-bar-width 5)
    (setq tab-bar-format '(episteme:tab-bar-format))
    :init
    (defun setup-custom-doom-modeline ()
      (doom-modeline-set-modeline 'epi-modeline t)
      (force-mode-line-update))
    (add-hook 'doom-modeline-mode-hook 'setup-custom-doom-modeline))
#+end_src

** doom theme
#+begin_src emacs-lisp
  (use-package doom-themes
    :ensure t
    :config
    ;; Global settings (defaults)
    (setq doom-themes-enable-bold t     ; if nil, bold is universally disabled
          doom-themes-enable-italic t)  ; if nil, italics is universally disabled
    (load-theme (intern (format "doom-%s" (or (getenv "theme") "laserwave"))) t)

    ;; Enable flashing mode-line on errors
    (doom-themes-visual-bell-config)
    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config))
#+end_src

* core settings
** autosaves
Periodically save a copy of open files.

*** autosave every file buffer
#+begin_src emacs-lisp
  (setq auto-save-default t)
#+end_src

*** save every 20 secs or 20 keystrokes
#+begin_src emacs-lisp
  (setq auto-save-timeout 20
        auto-save-interval 20)
#+end_src

*** keep autosaves in a single place
#+begin_src emacs-lisp
  (unless (file-exists-p episteme/autosaves)
      (make-directory episteme/autosaves))

  (setq auto-save-file-name-transforms
        `((".*" ,episteme/autosaves t)))
#+end_src

** backups
Backups are created everytime a buffer is manually saved.

*** backup every save
#+begin_src emacs-lisp
  (use-package backup-each-save
    :config (:hook after-save backup-each-save))
#+end_src

*** keep 10 backups
#+begin_src emacs-lisp
  (setq kept-new-versions 10)
#+end_src

*** delete old backups
#+begin_src emacs-lisp
  (setq delete-old-versions t)
#+end_src

*** copy files to avoid various problems
#+begin_src emacs-lisp
  (setq backup-by-copying t)
#+end_src

*** backup files even if version controlled
#+begin_src emacs-lisp
  (setq vc-make-backup-files t)
#+end_src

*** keep backups in a single place
#+begin_src emacs-lisp
  (unless (file-exists-p episteme/backups)
    (make-directory episteme/backups))

  (setq backup-directory-alist
        `((".*" . ,episteme/backups)))

  (setq make-backup-files t)
#+end_src

** cursor
*** box style
#+begin_src emacs-lisp
  (setq-default cursor-type 'box)
#+end_src

*** blinking
#+begin_src emacs-lisp
  (blink-cursor-mode 1)
#+end_src

** disable
Disable various UI and other features for a more minimal
experience.

*** menubar
#+begin_src emacs-lisp
  (menu-bar-mode -1)
#+end_src

*** toolbar
#+begin_src emacs-lisp
  (tool-bar-mode -1)
#+end_src

*** scrollbar
#+begin_src emacs-lisp
  (scroll-bar-mode -1)
#+end_src

*** startup message
#+begin_src emacs-lisp
  (setq inhibit-startup-message t
        initial-scratch-message nil)
#+end_src

*** customizations file
Disable the customizations file so there's no temptation to use the
customization interface.

#+begin_src emacs-lisp
  (setq custom-file (make-temp-file ""))
#+end_src

** editing
*** use spaces
#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src
*** global visual line wrap
#+begin_src emacs-lisp
  (global-visual-line-mode 1)
#+end_src
*** wrap lines at 79 characters
#+begin_src emacs-lisp
  (setq-default fill-column 79)
#+end_src

*** autowrap in text-mode
#+begin_src emacs-lisp
  ;; (:hook text-mode 'turn-on-auto-fill)
#+end_src

*** ssh for tramp
Default method for transferring files with Tramp.

#+begin_src emacs-lisp
  (setq tramp-default-method "ssh")
#+end_src

** minor-modes
*** whitespace-mode
Visually display trailing whitespace

#+begin_src emacs-lisp
  (use-package whitespace
    :custom
    (whitespace-style
     '(face tabs newline trailing tab-mark space-before-tab space-after-tab))
    :config
    (global-whitespace-mode 1))
#+end_src

*** prettify-symbols-mode
Replace various symbols with nice looking unicode glyphs.

#+begin_src emacs-lisp
  (global-prettify-symbols-mode 1)
#+end_src

*** electric-pair-mode
Automatically insert matching close-brackets for any open bracket.

#+begin_src emacs-lisp
  (electric-pair-mode 1)
#+end_src

*** rainbow-delimeters-mode
Color parenthesis based on their depth, using the golden ratio (because why
not).

#+begin_src emacs-lisp
  (require 'color)
  (defun gen-col-list (length s v &optional hval)
    (cl-flet ( (random-float () (/ (random 10000000000) 10000000000.0))
            (mod-float (f) (- f (ffloor f))) )
      (unless hval
        (setq hval (random-float)))
      (let ((golden-ratio-conjugate (/ (- (sqrt 5) 1) 2))
            (h hval)
            (current length)
            (ret-list '()))
        (while (> current 0)
          (setq ret-list
                (append ret-list
                        (list (apply 'color-rgb-to-hex (color-hsl-to-rgb h s v)))))
          (setq h (mod-float (+ h golden-ratio-conjugate)))
          (setq current (- current 1)))
        ret-list)))

  (defun set-random-rainbow-colors (s l &optional h)
    ;; Output into message buffer in case you get a scheme you REALLY like.
    ;; (message "set-random-rainbow-colors %s" (list s l h))
    (interactive)
    (rainbow-delimiters-mode t)

    ;; Show mismatched braces in bright red.
    (set-face-background 'rainbow-delimiters-unmatched-face "red")

    ;; Rainbow delimiters based on golden ratio
    (let ( (colors (gen-col-list 9 s l h))
           (i 1) )
      (let ( (length (length colors)) )
        ;;(message (concat "i " (number-to-string i) " length " (number-to-string length)))
        (while (<= i length)
          (let ( (rainbow-var-name (concat "rainbow-delimiters-depth-" (number-to-string i) "-face"))
                 (col (nth i colors)) )
            ;; (message (concat rainbow-var-name " => " col))
            (set-face-foreground (intern rainbow-var-name) col))
          (setq i (+ i 1))))))

  (use-package rainbow-delimiters :commands rainbow-delimiters-mode :hook ...
    :init
    (setq rainbow-delimiters-max-face-count 16)
    (set-random-rainbow-colors 0.6 0.7 0.5)
    (:hook prog-mode 'rainbow-delimiters-mode))
#+end_src

*** show-paren-mode
Highlight the matching open or closing bracket.

#+begin_src emacs-lisp
  (require 'paren)
  (show-paren-mode 1)
  (setq show-paren-delay 0)
  (:after xresources
    (set-face-foreground 'show-paren-match (theme-color 'green))
    (set-face-foreground 'show-paren-mismatch "#f00")
    (set-face-attribute 'show-paren-match nil :weight 'extra-bold)
    (set-face-attribute 'show-paren-mismatch nil :weight 'extra-bold))
#+end_src

*** which-key-mode
Show possible followups after pressing a key prefix.

#+begin_src emacs-lisp
  (use-package which-key
    :custom
    ;; sort single chars alphabetically P p Q q
    (which-key-sort-order 'which-key-key-order-alpha)
    (which-key-idle-delay 0.4)
    :config
    (which-key-mode))
#+end_src

*** company-mode
Show popup autocompletion.

#+begin_src emacs-lisp
  (use-package company
    :config
    (global-company-mode))
#+end_src

** shorten prompts
Shorten yes/no prompts to one letter.

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** visual
** zoom
Adjust font size in buffers or globally.

#+begin_src emacs-lisp
  (use-package zoom-frm
    :straight (zoom-frm :type git
                        :host github
                        :repo "emacsmirror/zoom-frm")
    :config
    (dotimes (i episteme/zoom) (zoom-frm-in)))
#+end_src

** cache
This speeds up help:unicode-fonts-setup after first run.

#+begin_src emacs-lisp
  (use-package persistent-soft)
#+end_src

** eval depth
Avoid elision (...) in messages.

#+begin_src emacs-lisp
  (setq print-level 100
        print-length 9999
        eval-expression-print-level 100
        eval-expression-print-length 9999)
#+end_src

** debug on error
Show tracebacks when errors happen.

#+begin_src emacs-lisp
  (setq debug-on-error t)
#+end_src

* helpful
Alternative to the built-in Emacs help that provides much more contextual
information.

#+begin_src emacs-lisp
  (use-package helpful
      :straight (helpful :type git :host github :repo "Wilfred/helpful")
      :bind (("C-h s" . #'helpful-symbol)
             ("C-h c" . #'helpful-command)
             ("C-h f" . #'helpful-function)
             ("C-h v" . #'helpful-variable)
             ("C-h k" . #'helpful-key)
             ("C-h m" . #'helpful-mode)
             ("C-h C-h" . #'helpful-at-point)))
#+end_src

** contextual help
*** toggle-context-help
#+begin_src emacs-lisp
  (defun toggle-context-help ()
    "Turn on or off the context help.
  Note that if ON and you hide the help buffer then you need to
  manually reshow it. A double toggle will make it reappear"
    (interactive)
    (with-current-buffer (help-buffer)
      (unless (local-variable-p 'context-help)
        (set (make-local-variable 'context-help) t))
      (if (setq context-help (not context-help))
          (progn
             (if (not (get-buffer-window (help-buffer)))
                 (display-buffer (help-buffer)))))
      (message "Context help %s" (if context-help "ON" "OFF"))))
#+end_src

*** context-help
#+begin_src emacs-lisp
  (defun context-help ()
    "Display function or variable at point in *Help* buffer if visible.
  Default behaviour can be turned off by setting the buffer local
  context-help to false"
    (interactive)
    (let ((rgr-symbol (symbol-at-point))) ; symbol-at-point http://www.emacswiki.org/cgi-bin/wiki/thingatpt%2B.el
      (with-current-buffer (help-buffer)
       (unless (local-variable-p 'context-help)
         (set (make-local-variable 'context-help) t))
       (if (and context-help (get-buffer-window (help-buffer))
           rgr-symbol)
         (if (fboundp  rgr-symbol)
             (describe-function rgr-symbol)
           (if (boundp  rgr-symbol) (describe-variable rgr-symbol)))))))
#+end_src

*** advise symbol eldoc
#+begin_src emacs-lisp
  (defadvice eldoc-print-current-symbol-info
    (around eldoc-show-c-tag activate)
    (cond
          ((eq major-mode 'emacs-lisp-mode) (context-help) ad-do-it)
          ((eq major-mode 'lisp-interaction-mode) (context-help) ad-do-it)
          ((eq major-mode 'apropos-mode) (context-help) ad-do-it)
          (t ad-do-it)))
#+end_src

* languages
** lispy-mode
#+begin_src emacs-lisp
  (use-package lispy
    :init
    (:hook emacs-lisp-mode (lispy-mode 1))
    (:hook lisp-interaction-mode (lispy-mode 1))
    :bind
    (":" . self-insert-command)
    ("[" . lispy-open-square)
    ("]" . lispy-close-square))
#+end_src
** json-mode
#+begin_src emacs-lisp
  (use-package json-mode
    :straight (json-mode :type git
                         :host github
                         :repo "kiennq/json-mode"
                         :branch "feat/jsonc-mode")
    :config
    (setf auto-mode-alist (assoc-delete-all "\\(?:\\(?:\\.\\(?:b\\(?:\\(?:abel\\|ower\\)rc\\)\\|json\\(?:ld\\)?\\)\\|composer\\.lock\\)\\'\\)"
                                            auto-mode-alist))
    (setf auto-mode-alist (assoc-delete-all "\\.json\\'" auto-mode-alist))
    (add-to-list 'auto-mode-alist '("\\.json\\'" . jsonc-mode)))
#+end_src

* helm
Menu and selection framework for finding files, switching buffers, running
grep, etc. A number of Episteme features are built ontop of Helm.

#+begin_src emacs-lisp
  (use-package helm
    :config
    (helm-mode 1)
    (require 'helm-config)
    :bind
    ("M-x" . helm-M-x)
    ("C-x C-f" . helm-find-files)
    ("C-x b" . helm-mini)
    ("C-c y" . helm-show-kill-ring)
    ("C-x C-r" . helm-recentf))
#+end_src
** ace jump
Quickly jump to any candidate with a short letter combo.

#+begin_src emacs-lisp
  (use-package ace-jump-helm-line
    :bind (:map helm-map
                ("C-;" . ace-jump-helm-line)))
#+end_src

** helm-ag
#+begin_src emacs-lisp
  (use-package helm-ag)
#+end_src

** helm-descbinds
Use (=C-h b= / =kbd-helm-descbinds=) to inspect current bindings with Helm.

#+begin_src emacs-lisp
  (use-package helm-descbinds
    :commands helm-descbinds
    :config
    (:bind "C-h b" nil helm-descbinds))
#+end_src

** auto full frame
Make Helm always full height.

#+begin_src emacs-lisp
  (defvar helm-full-frame-threshold 0.75)

  (when window-system
    (defun helm-full-frame-hook ()
    (let ((threshold (* helm-full-frame-threshold (x-display-pixel-height))))
      (setq helm-full-frame (< (frame-height) threshold))))

    (:hook helm-before-initialize 'helm-full-frame-hook))
#+end_src

* magit
The best git frontend there is.

#+begin_src emacs-lisp
  (use-package magit)
#+end_src
* org-mode
A souped up markup with tasking, scheduling and aggregation features.

** straight.el fixes
Fix some issues with straight.el and org until [[https://github.com/raxod502/straight.el#installing-org-with-straightel][that is resolved]].

*** fix-org-git-version
#+begin_src emacs-lisp
  (defun fix-org-git-version ()
    "The Git version of org-mode.
    Inserted by installing org-mode or when a release is made."
    (require 'git)
    (let ((git-repo (expand-file-name
                     "straight/repos/org/" user-emacs-directory)))
      (string-trim
       (git-run "describe"
                "--match=release\*"
                "--abbrev=6"
                "HEAD"))))
#+end_src

*** fix-org-release
#+begin_src emacs-lisp
  (defun fix-org-release ()
    "The release version of org-mode.
    Inserted by installing org-mode or when a release is made."
    (require 'git)
    (let ((git-repo (expand-file-name
                     "straight/repos/org/" user-emacs-directory)))
      (string-trim
       (string-remove-prefix
        "release_"
        (git-run "describe"
                 "--match=release\*"
                 "--abbrev=0"
                 "HEAD")))))
#+end_src

** installation
#+begin_src emacs-lisp
  (use-package org
    :config
    ;; these depend on the 'straight.el fixes' above
    (defalias #'org-git-version #'fix-org-git-version)
    (defalias #'org-release #'fix-org-release)
    (require 'org-habit)
    (require 'org-indent)
    (require 'org-capture)
    (require 'org-tempo)
    (add-to-list 'org-modules 'org-habit t))
#+end_src

** look
*** theme customizations
#+begin_src emacs-lisp
  (when window-system
    (use-package org-beautify-theme
      :after (org)
      :config
      (setq org-fontify-whole-heading-line t)
      (setq org-fontify-quote-and-verse-blocks t)
      (setq org-hide-emphasis-markers t)
      (cl-loop for (face . spec) in
       `((org-document-title .
          ((t (:inherit org-level-1 :height 2.0 :underline nil :box nil))))
         (org-level-1 . ((t (:height 1.5 :box nil))))
         (org-level-2 . ((t (:height 1.25 :box nil))))
         (org-level-3 . ((t (:box nil))))
         (org-level-4 . ((t (:box nil))))
         (org-level-5 . ((t (:box nil))))
         (org-level-6 . ((t (:box nil))))
         (org-level-7 . ((t (:box nil))))
         (org-level-8 . ((t (:box nil))))
         (org-link . ((t (:underline t)))))
       do (face-spec-set face spec))))
#+end_src

*** pretty symbols
Add a hook to set the pretty symbols alist.

#+begin_src emacs-lisp
  (setq episteme/pretty-symbols nil)
  (:hook org-mode
    (setq-local prettify-symbols-alist episteme/pretty-symbols))
#+end_src
*** indent by header level
Hide the heading asterisks. Instead indent headings based on depth.

#+begin_src emacs-lisp
  (:hook org-mode 'org-indent-mode)
#+end_src

*** pretty heading bullets
Use nice unicode bullets instead of the default asterisks.

#+begin_src emacs-lisp
  (use-package org-bullets
    :init
    (:hook org-mode 'org-bullets-mode)
    :config
    (setq org-bullets-bullet-list '("â—‰" "â—‹" "âœ¸" "â€¢")))
#+end_src

*** pretty priority cookies
Instead of the default =[#A]= and =[#C]= priority cookies, use little unicode arrows to
indicate high and low priority. =[#B]=, which is the same as no priority, is shown as
normal.

#+begin_src emacs-lisp
  (:push episteme/pretty-symbols
    '("[#A]" . "â‡‘")
    '("[#C]" . "â‡“"))
#+end_src

#+begin_src emacs-lisp
  ;; only show priority cookie symbols on headings.
  (defun nougat/org-pretty-compose-p (start end match)
    (if (or (string= match "[#A]") (string= match "[#C]"))
        ;; prettify asterisks in headings
        (org-match-line org-outline-regexp-bol)
      ;; else rely on the default function
      (funcall #'prettify-symbols-default-compose-p start end match)))


  (:hook org-mode (setq-local prettify-symbols-compose-predicate
                              #'nougat/org-pretty-compose-p))
#+end_src

*** pretty heading ellipsis
Show a little arrow for collapsed headings.

#+begin_src emacs-lisp
  (:after org
    (setq org-ellipsis " â–¿"))
#+end_src

*** prettify source blocks
#+begin_src emacs-lisp
  (:push episteme/pretty-symbols
    '("#+begin_src" . ">>")
    '("#+end_src" . "Â·"))
#+end_src
*** dynamic tag position
#+begin_src emacs-lisp
  (defun org-realign-tags ()
    (interactive)
    (setq org-tags-column (- 0 (window-width)))
    (org-align-tags t))

  ;; (:hook window-configuration-change 'org-realign-tags)
#+end_src

** feel
*** show all headings on startup
#+begin_src emacs-lisp
  (setq org-startup-folded 'content)
#+end_src

*** don't fold blocks on open
#+begin_src emacs-lisp
  (setq org-hide-block-startup nil)
#+end_src

*** resepect content on insert
Don't split existing entries when inserting a new heading.

#+begin_src emacs-lisp
  (setq org-insert-heading-respect-content nil)
#+end_src

*** use helpful for help links
#+begin_src emacs-lisp
  (advice-add 'org-link--open-help :override
              (lambda (path) (helpful-symbol (intern path))))
#+end_src
** todo keywords
*** boilerplate
**** make-state-model
#+begin_src emacs-lisp
  (defun todo-make-state-model (name key props)
    (append (list :name name :key key) props))
#+end_src
**** parse-state-data
#+begin_src emacs-lisp
  (defun todo-parse-state-data (state-data)
    (-let* (((name second &rest) state-data)
            ((key props) (if (stringp second)
                             (list second (cddr state-data))
                           (list nil (cdr state-data)))))
      (todo-make-state-model name key props)))
#+end_src
**** make-sequence-mode
#+begin_src emacs-lisp
  (defun todo-make-sequence-model (states)
    (mapcar 'todo-parse-state-data states))
#+end_src
**** parse-sequences-data
#+begin_src emacs-lisp
  (defun todo-parse-sequences-data (sequences-data)
    (mapcar 'todo-make-sequence-model sequences-data))
#+end_src
**** todo-keyword-name
#+begin_src emacs-lisp
  (defun todo-keyword-name (name key)
    (if key (format "%s(%s)" name key) name))
#+end_src
**** keyword-name-forstate
#+begin_src emacs-lisp
  (defun todo-keyword-name-for-state (state)
    (todo-keyword-name (plist-get state :name)
                       (plist-get state :key)))
#+end_src
**** is-done-state
#+begin_src emacs-lisp
  (defun todo-is-done-state (state)
    (equal t (plist-get state :done-state)))
#+end_src
**** is-not-done-state
#+begin_src emacs-lisp
  (defun todo-is-not-done-state (state)
    (equal nil (plist-get state :done-state)))
#+end_src
**** org-sequence
#+begin_src emacs-lisp
  (defun todo-org-sequence (states)
    (let ((active (seq-filter 'todo-is-not-done-state states))
          (inactive (seq-filter 'todo-is-done-state states)))
      (append '(sequence)
              (mapcar 'todo-keyword-name-for-state active)
              '("|")
              (mapcar 'todo-keyword-name-for-state inactive))))
#+end_src
**** org-todo-keywords
#+begin_src emacs-lisp
  (defun todo-org-todo-keywords (sequences)
    (mapcar 'todo-org-sequence (todo-parse-sequences-data sequences)))
  ;; (todo-org-todo-keywords todo-keywords)
#+end_src
**** org-todo-keyword-faces
#+begin_src emacs-lisp
  (defun todo-org-todo-keyword-faces (sequences)
    (cl-loop for sequence in (todo-parse-sequences-data sequences)
             append (cl-loop for state in sequence
                             for name = (plist-get state :name)
                             for face = (plist-get state :face)
                             collect (cons name face))))
  ;; (todo-org-todo-keyword-faces todo-keywords)
#+end_src
**** prettify-symbols-alist
#+begin_src emacs-lisp
  (defun todo-prettify-symbols-alist (sequences)
    (cl-loop for sequence in (todo-parse-sequences-data sequences)
             append (cl-loop for state in sequence
                             for name = (plist-get state :name)
                             for icon = (plist-get state :icon)
                             collect (cons name icon))))
  ;; (todo-prettify-symbols-alist todo-keywords)
#+end_src
**** finalize-agenda-for-state
#+begin_src emacs-lisp
  (defun todo-finalize-agenda-for-state (state)
    (-let (((&plist :name :icon :face) state))
      (beginning-of-buffer)
      (while (search-forward name nil 1)
        (let* ((line-props (text-properties-at (point)))
               (line-props (org-plist-delete line-props 'face)))
          (call-interactively 'set-mark-command)
          (search-backward name)
          (call-interactively 'kill-region)
          (let ((symbol-pos (point)))
            (insert icon)
            (beginning-of-line)
            (let ((start (point))
                  (end (progn (end-of-line) (point))))
              (add-text-properties start end line-props)
              (add-face-text-property symbol-pos (+ 1 symbol-pos) face))))))
    (beginning-of-buffer)
    (replace-regexp "[[:space:]]+[=]+" ""))
#+end_src

*** keywords
#+begin_src emacs-lisp
  (setq todo-keywords
        ;; normal workflow
        '((("DOING" "d" :icon "ðŸƒ" :face org-doing-face)
           ("TODO" "t" :icon "â–¡â€„" :face org-todo-face)
           ("DONE" "D" :icon "âœ“â€„" :face org-done-face :done-state t))
          ;; auxillary states
          (("SOON" "s" :icon "â—â€€" :face org-soon-face)
           ("SOMEDAY" "S" :icon "ðŸ›Œ" :face org-doing-face)))
        org-todo-keywords (todo-org-todo-keywords todo-keywords)
        org-todo-keyword-faces (todo-org-todo-keyword-faces todo-keywords))

  (--map (:push episteme/pretty-symbols it)
         (todo-prettify-symbols-alist todo-keywords))
#+end_src

*** org agenda finalization
#+begin_src emacs-lisp
  (setq episteme/todo-sequences-data (todo-parse-sequences-data todo-keywords))
  (:hook org-agenda-finalize
    (--each episteme/todo-sequences-data
      (-each it 'todo-finalize-agenda-for-state)))
#+end_src
*** sorting
#+begin_src emacs-lisp
  (defun episteme:todo-sort (a b)
    (let* ((a-state (get-text-property 0 'todo-state a))
           (b-state (get-text-property 0 'todo-state b))
           (a-index (-elem-index a-state todo-keyword-order))
           (b-index (-elem-index b-state todo-keyword-order)))
      (pcase (- b-index a-index)
        ((and v (guard (< 0 v))) 1)
        ((and v (guard (> 0 v))) -1)
        (default nil))))

  (setq org-agenda-cmp-user-defined 'episteme:todo-sort
        todo-keyword-order '("DOING" "SOON" "TODO" "SOMEDAY" "DONE"))
#+end_src

** org-babel
*** babel languages
**** ob-csharp
#+begin_src emacs-lisp
  (use-package ob-csharp
    :straight (ob-csharp :type git
                         :host github
                         :repo "thomas-villagers/ob-csharp"
                         :files ("src/ob-csharp.el"))
    :config
    (:push org-babel-load-languages '(csharp . t)))
#+end_src
**** ob-fsharp
#+begin_src emacs-lisp
  (use-package ob-fsharp
    :straight (ob-fsharp :type git
                         :host github
                         :repo "zweifisch/ob-fsharp"
                         :files ("ob-fsharp.el"))
    :config
    (:push org-babel-load-languages '(fsharp . t)))
#+end_src
*** enable languages
#+begin_src emacs-lisp
  (setq org-babel-load-languages
        '((shell . t)
          (emacs-lisp . t)
          (python . t)
          (js . t)
          (csharp . t)
          (fsharp . t)))
#+end_src

*** default header args
#+begin_src emacs-lisp
  (:after org
    (setq org-babel-default-header-args
          '((:session . "none")
            (:results . "replace")
            (:exports . "code")
            (:cache . "no")
            (:noweb . "no")
            (:hlines . "no")
            (:tangle . "no"))))
#+end_src

*** security
Disable prompts for evaluating org-mode links.
#+begin_src emacs-lisp
  (progn
    (setq org-confirm-babel-evaluate nil)
    (setq org-confirm-elisp-link-function nil)
    (setq org-confirm-shell-link-function nil)
    (setq safe-local-variable-values '((org-confirm-elisp-link-function . nil))))
#+end_src
*** install babel handlers
#+begin_src emacs-lisp
  (:hook after-init
    (org-babel-do-load-languages 'org-babel-load-languages
                                 org-babel-load-languages))
#+end_src

** org-fragtog
Automatically preview LaTex fragments.

#+begin_src emacs-lisp
  (use-package org-fragtog
    :config
    (:hook org-mode 'org-fragtog-mode))
#+end_src

** helm-org
#+begin_src emacs-lisp
  (use-package helm-org)
#+end_src
** helm-org-rifle
Quickly search through the current org buffer.

#+begin_src emacs-lisp
  (use-package helm-org-rifle)
#+end_src
** helm-org-walk
Easily navigate Org files with Helm.
#+begin_src emacs-lisp
  (use-package helm-org-walk
    :straight (helm-org-walk :type git :host github :repo "dustinlacewell/helm-org-walk"))
#+end_src
** org-ql
Query Org files for elements.
#+begin_src emacs-lisp
  (use-package org-ql)
#+end_src
** org-ls
Interact with babel codeblocks from elisp.
#+begin_src emacs-lisp
  (use-package org-ls
    :straight (org-ls :type git :host github :repo "dustinlacewell/org-ls"))
#+end_src
** org-journal
#+begin_src emacs-lisp
  (use-package org-journal
    :config
    (setq org-journal-dir episteme/journal)
    (setq org-journal-file-type 'weekly))
#+end_src

** org-roam
Backlink support
#+begin_src emacs-lisp
  (defun episteme:ensure-org-id ()
    (interactive)
    (when (s-starts-with? episteme/current-remote-root (buffer-file-name))
      (save-excursion
        (beginning-of-buffer)
        (org-id-get-create))))

  (use-package org-roam
    :ensure t
    :init
    (setq org-roam-v2-ack 2)
    :bind (("C-c n l" . org-roam-buffer-toggle)
           ("C-c n f" . org-roam-node-find)
           ("C-c n g" . org-roam-graph)
           ("C-c n i" . org-roam-node-insert)
           ("C-c n c" . org-roam-capture)
           ;; Dailies
           ("C-c n j" . org-roam-dailies-capture-today))
    :config
    (setq org-roam-directory episteme/current-remote-root)

    ;; STOP PREPENDING DATES >:|
    (setq org-roam-capture-templates '(("d" "default" plain "%?" :target
                                        (file+head "${slug}.org" "#+TITLE: ${title}\n")
                                        :unnarrowed t)))
    (setq org-roam-extract-new-file-path "${slug}.org")

    ;; STOP USING "_" instead of "-" >:|
    (cl-defmethod org-roam-node-slug ((node org-roam-node))
      (let ((title (org-roam-node-title node))
            (slug-trim-chars '(;; Combining Diacritical Marks https://www.unicode.org/charts/PDF/U0300.pdf
                               768 ; U+0300 COMBINING GRAVE ACCENT
                               769 ; U+0301 COMBINING ACUTE ACCENT
                               770 ; U+0302 COMBINING CIRCUMFLEX ACCENT
                               771 ; U+0303 COMBINING TILDE
                               772 ; U+0304 COMBINING MACRON
                               774 ; U+0306 COMBINING BREVE
                               775 ; U+0307 COMBINING DOT ABOVE
                               776 ; U+0308 COMBINING DIAERESIS
                               777 ; U+0309 COMBINING HOOK ABOVE
                               778 ; U+030A COMBINING RING ABOVE
                               780 ; U+030C COMBINING CARON
                               795 ; U+031B COMBINING HORN
                               803 ; U+0323 COMBINING DOT BELOW
                               804 ; U+0324 COMBINING DIAERESIS BELOW
                               805 ; U+0325 COMBINING RING BELOW
                               807 ; U+0327 COMBINING CEDILLA
                               813 ; U+032D COMBINING CIRCUMFLEX ACCENT BELOW
                               814 ; U+032E COMBINING BREVE BELOW
                               816 ; U+0330 COMBINING TILDE BELOW
                               817))) ; U+0331 COMBINING MACRON BELOW
        (cl-flet* ((nonspacing-mark-p (char)
                                      (memq char slug-trim-chars))
                   (strip-nonspacing-marks (s)
                                           (ucs-normalize-NFC-string
                                            (apply #'string (seq-remove #'nonspacing-mark-p
                                                                        (ucs-normalize-NFD-string s)))))
                   (cl-replace (title pair)
                               (replace-regexp-in-string (car pair) (cdr pair) title)))
          (let* ((pairs `(("[^[:alnum:][:digit:]]" . "-")
                          ("--*" . "-")
                          ("^-" . "")
                          ("-$" . "")))
                 (slug (-reduce-from #'cl-replace (strip-nonspacing-marks title) pairs)))
            (downcase slug)))))

    ;; If using org-roam-protocol
    (require 'org-roam-protocol)
    (:hook org-mode
     (add-hook 'before-save-hook 'episteme:ensure-org-id nil t)))
#+end_src
* other packages
** persistent-scratch
#+begin_src emacs-lisp
  (use-package persistent-scratch
    :config
    (persistent-scratch-setup-default)
    (setq persistent-scratch-save-file (concat episteme/home "/scratch")
          persistent-scratch-autosave-interval 20))
#+end_src
** embrace
#+begin_src emacs-lisp
  (use-package embrace
    :config
    (embrace-add-pair (kbd "\;") "`" "`"))
#+end_src

** htmlize
Allows org codeblocks to be syntax highlighted on html export.

#+begin_src emacs-lisp
  (use-package htmlize)
#+end_src

* hydra
[[https://github.com/abo-abo/hydra][Hydra]] provides customizable interactive command palettes.

** pretty-hydra
[[https://github.com/jerrypnz/major-mode-hydra.el#pretty-hydra][Pretty-hydra]] provides a macro that makes it easy to get good looking hydras.

#+begin_src emacs-lisp
  (use-package pretty-hydra
    :demand t
    :straight (pretty-hydra :type git :host github
                            :repo "jerrypnz/major-mode-hydra.el"
                            :files ("pretty-hydra.el")))
#+end_src

** major-mode-hydra
[[https://github.com/jerrypnz/major-mode-hydra.el][Major-mode-hydra]] associates hydras with major-modes.

#+begin_src emacs-lisp
  (use-package major-mode-hydra
    :straight (major-mode-hydra :type git :host github
                                :repo "jerrypnz/major-mode-hydra.el"
                                :files ("major-mode-hydra.el")))
#+end_src

** hera
[[https://github.com/dustinlacewell/hera][Hera]] lets hydras form a stack.

#+begin_src emacs-lisp
  (use-package hera
    :demand t
    :straight (hera :type git :host github :repo "dustinlacewell/hera"))
#+end_src

** :hydra
Macro for defining Hydras.

*** boilerplate
**** inject-hint
#+begin_src emacs-lisp
  (defun :hydra/inject-hint (symbol hint)
    (-let* ((name (symbol-name symbol))
            (hint-symbol (intern (format "%s/hint" name)))
            (format-form (eval hint-symbol))
            (string-cdr (nthcdr 1 format-form))
            (format-string (string-trim (car string-cdr)))
            (amended-string (format "%s\n\n%s" format-string hint)))
      (setcar string-cdr amended-string)))
#+end_src

**** make-head-hint
#+begin_src emacs-lisp
  (defun :hydra/make-head-hint (head default-color)
    (-let (((key _ hint . rest) head))
      (when key
        (-let* (((&plist :color color) rest)
                (color (or color default-color))
                (face (intern (format "hydra-face-%s" color)))
                (propertized-key (propertize key 'face face)))
          (format " [%s]: %s" propertized-key hint)))))
#+end_src

**** make-hint
#+begin_src emacs-lisp
  (defun :hydra/make-hint (heads default-color)
    (string-join
     (cl-loop for head in heads
              for hint = (:hydra/make-head-hint head default-color)
              collect hint) "\n"))
#+end_src

**** clear-hint
#+begin_src emacs-lisp
  (defun :hydra/clear-hint (head)
    (-let* (((key form _ . rest) head))
      `(,key ,form nil ,@rest)))
#+end_src

**** add-exit-head
#+begin_src emacs-lisp
  (defun :hydra/add-exit-head (heads)
    (let ((exit-head '("SPC" (hera-pop) "to exit" :color blue)))
      (append heads `(,exit-head))))
#+end_src

**** add-heads
#+begin_src emacs-lisp
    (defun :hydra/add-heads (columns extra-heads)
      (let* ((cell (nthcdr 1 columns))
             (heads (car cell))
             (extra-heads (mapcar ':hydra/clear-hint extra-heads)))
        (setcar cell (append heads extra-heads))))

#+end_src

*** macro
#+begin_src emacs-lisp
    (defmacro :hydra (name body columns &optional extra-heads)
      (declare (indent defun))
      (-let* (((&plist :color default-color :major-mode mode) body)
              (extra-heads (:hydra/add-exit-head extra-heads))
              (extra-hint (:hydra/make-hint extra-heads default-color))
              (body (plist-put body :hint nil))
              (body-name (format "%s/body" (symbol-name name)))
              (body-symbol (intern body-name))
              (mode-body-name (major-mode-hydra--body-name-for mode))
              (mode-support
               `(when ',mode
                  (defun ,mode-body-name () (interactive) (,body-symbol)))))
        (:hydra/add-heads columns extra-heads)
        (when mode
          (cl-remf body :major-mode))
        `(progn
           (pretty-hydra-define ,name ,body ,columns)
           (:hydra/inject-hint ',name ,extra-hint)
           ,mode-support
           )))
#+end_src

*** tests
#+begin_src emacs-lisp
    ;; (macroexpand-all `(:hydra hydra-test (:color red :major-mode fundamental-mode)
    ;;    ("First"
    ;;     (("a" (message "first - a") "msg a" :color blue)
    ;;      ("b" (message "first - b") "msg b"))
    ;;     "Second"
    ;;     (("c" (message "second - c") "msg c" :color blue)
    ;;      ("d" (message "second - d") "msg d")))))

    ;; (:hydra hydra-test (:color red :major-mode fundamental-mode)
    ;;    ("First"
    ;;     (("a" (message "first - a") "msg a" :color blue)
    ;;      ("b" (message "first - b") "msg b"))
    ;;     "Second"
    ;;     (("c" (message "second - c") "msg c" :color blue)
    ;;      ("d" (message "second - d") "msg d"))))

#+end_src

* treemacs
#+begin_src emacs-lisp
  (use-package treemacs
    :demand t
    :custom
    (treemacs--project-follow-delay 0.5))

  (defun episteme:show-sidebar ()
    (interactive)
    (let ((current-window (get-buffer-window))
          (treemacs--find-user-project-functions
           '((lambda () episteme/current-remote-root))))
      (treemacs-display-current-project-exclusively)
      (select-window current-window)))

  (defun episteme:toggle-sidebar ()
    (interactive)
    (if-let (win (treemacs-get-local-window))
        (progn (treemacs-select-window)
               (kill-buffer-and-window))
      (episteme:show-sidebar)))
#+end_src

* main menu
** hydra-help
Many of the Emacs help facilities at your fingertips!

#+begin_src emacs-lisp

  (:hydra episteme-hydra-help (:color blue)
    ("Describe"
     (("c" describe-function "function")
      ("p" describe-package "package")
      ("m" describe-mode "mode")
      ("v" describe-variable "variable"))
     "Keys"
     (("k" describe-key "key")
      ("K" describe-key-briefly "brief key")
      ("w" where-is "where-is")
      ("b" helm-descbinds "bindings"))
     "Search"
     (("a" helm-apropos "apropos")
      ("d" apropos-documentation "documentation")
      ("s" info-lookup-symbol "symbol info"))
     "Docs"
     (("i" info "info")
      ("n" helm-man-woman "man")
      ("h" helm-dash "dash"))
     "View"
     (("e" view-echo-area-messages "echo area")
      ("l" view-lossage "lossage")
      ("c" describe-coding-system "encoding")
      ("I" describe-input-method "input method")
      ("C" describe-char "char at point"))))
#+end_src

** hydra-mark
#+begin_src emacs-lisp
  (defun unpop-to-mark-command ()
    "Unpop off mark ring. Does nothing if mark ring is empty."
    (when mark-ring
      (setq mark-ring (cons (copy-marker (mark-marker)) mark-ring))
      (set-marker (mark-marker) (car (last mark-ring)) (current-buffer))
      (when (null (mark t)) (ding))
      (setq mark-ring (nbutlast mark-ring))
      (goto-char (marker-position (car (last mark-ring))))))

  (defun push-mark ()
    (interactive)
    (set-mark-command nil)
    (set-mark-command nil))

  (:hydra episteme-hydra-mark (:color pink)
    ("Mark"
     (("m" push-mark "mark here")
      ("p" (lambda () (interactive) (set-mark-command '(4))) "previous")
      ("n" (lambda () (interactive) (unpop-to-mark-command)) "next")
      ("c" (lambda () (interactive) (setq mark-ring nil)) "clear"))))
#+end_src

** hydra-registers
#+begin_src emacs-lisp
  (:hydra episteme-hydra-registers (:color pink)
    ("Point"
     (("r" point-to-register "save point")
      ("j" jump-to-register "jump")
      ("v" view-register "view all"))
     "Text"
     (("c" copy-to-register "copy region")
      ("C" copy-rectangle-to-register "copy rect")
      ("i" insert-register "insert")
      ("p" prepend-to-register "prepend")
      ("a" append-to-register "append"))
     "Macros"
     (("m" kmacro-to-register "store")
      ("e" jump-to-register "execute"))))

#+end_src

** hydra-window
#+begin_src emacs-lisp
  (use-package ace-window)
  (winner-mode 1)

  (:hydra episteme-hydra-window (:color red)
    ("Jump"
     (("h" windmove-left "left")
      ("l" windmove-right "right")
      ("k" windmove-up "up")
      ("j" windmove-down "down")
      ("a" ace-select-window "ace"))
     "Split"
     (("q" split-window-right "left")
      ("r" (progn (split-window-right) (call-interactively 'other-window)) "right")
      ("e" split-window-below "up")
      ("w" (progn (split-window-below) (call-interactively 'other-window)) "down"))
     "Do"
     (("d" delete-window "delete")
      ("o" delete-other-windows "delete others")
      ("u" winner-undo "undo")
      ("R" winner-redo "redo")
      ("t" nougat-hydra-toggle-window "toggle"))))
#+end_src

** hydra-zoom
#+begin_src emacs-lisp
  (:hydra episteme-hydra-zoom (:color red)
    ("Buffer"
     (("i" text-scale-increase "in")
      ("o" text-scale-decrease "out"))
     "Frame"
     (("I" zoom-frm-in "in")
      ("O" zoom-frm-out "out")
      ("r" toggle-zoom-frame "reset" :color blue))))
#+end_src

** hydra-dev
#+begin_src emacs-lisp
  (defun episteme:dev-log ()
    (interactive)
    (let* ((_org-journal-dir org-journal-dir))
      (setq org-journal-dir (concat episteme/support "/devlog"))
      (org-journal-new-entry nil)
      (setq org-journal-dir _org-journal-dir)))

  (:hydra episteme-hydra-dev (:color blue)
    ("Open"
     (("s" (find-file (concat episteme/support "/support.org")) "support.org")
      ("d" (find-file (concat episteme/org "/episteme/developer-docs.org")) "docs")
      ("l" (call-interactively 'episteme:dev-log) "log"))
     "Git"
     (("g" (magit-status episteme/support) "magit")
      ("p" (magit-pull episteme/support) "pull")
      ("R" (magit-reset-hard)))))
#+end_src

** hydra-remotes
#+begin_src emacs-lisp
    (:hydra episteme-hydra-remotes (:color blue)
      ("Knowledge-bases  "
       (("l" (call-interactively (lambda () (interactive) (episteme:pick-remote))) "list")
        ("a" (lambda () (interactive) (episteme:do-activate-remote)) "activate")
        ("n" episteme:do-add-remote "new")
        ("u" episteme:do-update-remote "update")
        ("r" episteme:do-remove-remote "remove")
        ("g" episteme:do-remote-status "git status")
        ("s" episteme:do-set-remote-url "set url"))
       "Epicenter"
       (("U" (epicenter:update-remotes) "update epicenter")
        ("i" (epicenter:do-track-remote) "install community kb"))))
#+end_src

** hydra-default
#+begin_src emacs-lisp
  (:hydra episteme-hydra-default (:color blue)
    ("Open"
     (("!" (episteme:cleanup) "dashboard")
      ("o" (episteme:open) "open")
      ("s" (episteme:search) "search")
      ("a" (episteme:find) "all files")
      ("t" (episteme:todo) "todo")
      ("j" (episteme:journal) "journal")
      ("J" (episteme:journal-entry) "new journal entry")
      ("k" (hera-push 'episteme-hydra-remotes/body) "knowledge-bases"))
     "Emacs"
     (("h" (hera-push 'episteme-hydra-help/body) "help")
      ("m" (hera-push 'episteme-hydra-mark/body) "mark")
      ("w" (hera-push 'episteme-hydra-window/body) "windows")
      ("z" (hera-push 'episteme-hydra-zoom/body) "zoom")
      ("r" (hera-push 'episteme-hydra-registers/body) "registers")
      (";" embrace-commander "parens / quotes"))
     "Bookmarks"
     (("S" episteme:toggle-sidebar "sidebar" :color red)
      ("D" (episteme:find (concat episteme/support "/docs")) "docs")
      ("C" (find-file (concat episteme/support "/docs/cheatsheet.org")) "cheatsheet")
      ("U" (find-file (concat episteme/support "/docs/user-guide.org")) "user guide")
      ("I" (find-file (concat episteme/support "/README.org")) "readme"))
     "Misc"
     (("." (hera-push 'episteme-hydra-dev/body) "dev tools"))))
#+end_src

*** open
#+begin_src emacs-lisp
  (defun episteme:open ()
    (interactive)
    (helm-org-walk '(4)))
#+end_src
*** search
#+begin_src emacs-lisp
  (defun episteme:search ()
    (interactive)
    (helm-org-rifle-directories episteme/current-remote-root))
#+end_src
*** find
#+begin_src emacs-lisp
  (defun episteme:find (&optional path)
    (interactive)
    (let ((file-name
           (completing-read "file: "
                            (directory-files-recursively
                             (or path episteme/current-remote-root) "\.org$"))))
      (find-file file-name)))
#+end_src
*** todo
#+begin_src emacs-lisp
  (defun episteme:todo ()
    (interactive)
    (find-file episteme/todo-file))
#+end_src
*** journal
#+begin_src emacs-lisp
  (defun episteme:journal ()
    (interactive)
    (org-journal-new-entry '(4)))
#+end_src
*** journal-entry
#+begin_src emacs-lisp
  (defun episteme:journal-entry ()
    (interactive)
    (org-journal-new-entry nil))
#+end_src
*** cleanup
#+begin_src emacs-lisp
  (defun episteme:cleanup ()
    (interactive)
    (mapc 'kill-buffer (--filter (not (buffer-modified-p it)) (buffer-list)))
    (delete-other-windows)
    (episteme:dashboard))
#+end_src
* mode menus
** boilerplate
*** hydra-dwim
Open hydra for current major mode if one exists, otherwise the default hydra.
#+begin_src emacs-lisp
  (defun episteme:hydra-dwim ()
    (interactive)
    (let* ((mode major-mode)
          (orig-mode mode))
      (catch 'done
        (while mode
          (let ((hydra (major-mode-hydra--body-name-for mode)))
            (when (fboundp hydra)
              (hera-start hydra)
              (throw 'done t)))
          (setq mode (get mode 'derived-mode-parent)))
        (hera-start 'hydra-default/body))))
#+end_src
** hydra-text
#+begin_src emacs-lisp
  (defun wtf ()
    (interactive)
    (table-save-horizontal nil))

  (defun table-cell-p ()
    (table--at-cell-p (point)))

  (defun table-settle-row ()
    (interactive)
    (if (bobp)
        (progn
          (forward-char)
          (next-line))
      (if (eq 1 (line-number-at-pos))
          (if (eq ?- (char-after))
              (next-line)
            (progn
              (backward-char)
              (next-line)))
        (when (eolp)
          (backward-char))
        (while (not (table-cell-p))
          (call-interactively 'previous-line)))))

  (defun table-settle-column ()
    (interactive)
    (if (eq 0 (current-column))
        (forward-char)
      (while (not (table-cell-p))
        (backward-char))))

  (defun table-settle ()
    (interactive)
    (pcase (char-after)
      ((pred (lambda (it) (eq ?- it))) (table-settle-row))
      ((pred (lambda (it) (eq ?| it))) (table-settle-column))
      ((pred (lambda (it) (eq ?+ it))) (progn
                                         (forward-char)
                                         (table-settle-row)))))

  (defun table-row-cells ()
    (table--cell-list-to-coord-list
     (table--horizontal-cell-list t nil 'top)))

  (defun table-column-cells ()
    (table--cell-list-to-coord-list
     (table--vertical-cell-list t nil 'left)))

  (defun table-vertical-index (y cells)
    (--find-index
     (-let* (((tl . br) it)
             ((tlx . tly) tl)
             ((brx . bry) br))
       (and (>= y tly)
            (<= y bry)))
     cells))

  (defun table-horizontal-index (x cells)
    (--find-index
     (-let* (((tl . br) it)
             ((tlx . tly) tl)
             ((brx . bry) br))
       (and (>= x tlx)
            (<= x brx)))
     cells))

  (defun table-get-coordinate ()
    (-let* ((row-cells (table-row-cells))
            (col-cells (table-column-cells))
            ((x . y) (table--get-coordinate))
            (row-index (table-vertical-index y col-cells))
            (col-index (table-horizontal-index x row-cells)))
      (cons col-index row-index)))

  (defun table-first-row-p ()
    (-let* ((cells (table-column-cells))
            ((x . y) (table--get-coordinate))
            (index (table-vertical-index y cells)))
      (eq 0 index)))

  (defun table-last-row-p ()
    (-let* ((cells (table-column-cells))
            ((x . y) (table--get-coordinate))
            (index (table-vertical-index y cells)))
      (eq index (- (length cells) 1))))

  (defun table-first-column-p ()
    (-let* ((cells (table-row-cells))
            ((x . y) (table--get-coordinate))
            (index (table-horizontal-index x cells)))
      (eq 0 index)))

  (defun table-last-column-p ()
    (-let* ((cells (table-row-cells))
            ((x . y) (table--get-coordinate))
            (index (table-horizontal-index x cells)))
      (eq index (- (length cells) 1))))

  (defmacro table-save-vertical (&rest body)
    `(when (table-cell-p)
       (-let* ((cells (table-column-cells))
               ((ox . oy) (table--get-coordinate))
               (index (table-vertical-index oy cells)))
         ,@body
         (table-settle)
         (-let* ((newcells (table-column-cells))
                 (clean-index (max 0 (min (- (length newcells) 1) index)))
                 ((tl . br) (nth clean-index newcells)))
           (table--goto-coordinate tl)
           (table-settle)))))

  (defmacro table-save-horizontal (&rest body)
    `(when (table-cell-p)
       (-let* ((cells (table-row-cells))
               ((ox . oy) (table--get-coordinate))
               (index (table-horizontal-index ox cells)))
         ,@body
         (table-settle)
         (-let* ((newcells (table-row-cells))
                 (clean-index (max 0 (min (- (length newcells) 1) index)))
                 ((tl . br) (nth clean-index newcells)))
           (table--goto-coordinate tl)
           (table-settle)))))

  ;;
  ;; Motion
  ;;

  (defun table-goto-first-row ()
    (interactive)
    (when (table-cell-p)
      (-let* ((coord-list
               (table--cell-list-to-coord-list
                (table--vertical-cell-list t nil 'left)))
              ((ful . fbr) (car coord-list))
              ((lul . lbr) (-last-item coord-list)))
        (table--goto-coordinate ful))))

  (defun table-go-up ()
    (interactive)
    (when (not (table-first-row-p))
      (-let* ((cells
               (table--cell-list-to-coord-list
                (table--vertical-cell-list t nil 'left)))
              ((ox . oy) (table--get-coordinate))
              (current-index (table-vertical-index oy cells))
              (target-index (- current-index 1))
              ((tl . br) (nth target-index cells)))
        (table--goto-coordinate tl))))

  (defun table-go-down ()
    (interactive)
    (when (not (table-last-row-p))
      (-let* ((cells
               (table--cell-list-to-coord-list
                (table--vertical-cell-list t nil 'left)))
              ((ox . oy) (table--get-coordinate))
              (current-index (table-vertical-index oy cells))
              (target-index (+ current-index 1))
              ((tl . br) (nth target-index cells)))
        (table--goto-coordinate tl))))

  (defun table-go-left ()
    (interactive)
    (when (not (table-first-column-p))
      (-let* ((cells
               (table--cell-list-to-coord-list
                (table--horizontal-cell-list t nil 'left)))
              ((ox . oy) (table--get-coordinate))
              (current-index (table-horizontal-index ox cells))
              (target-index (- current-index 1))
              ((tl . br) (nth target-index cells)))
        (table--goto-coordinate tl))))

  (defun table-go-right ()
    (interactive)
    (when (not (table-last-column-p))
      (-let* ((cells
               (table--cell-list-to-coord-list
                (table--horizontal-cell-list t nil 'top)))
              ((ox . oy) (table--get-coordinate))
              (current-index (table-horizontal-index ox cells))
              (target-index (+ current-index 1))
              ((tl . br) (nth target-index cells)))
        (table--goto-coordinate tl))))

  (cl-defun table-mark-row (&key extend-top
                                 extend-left
                                 extend-right
                                 extend-bottom)
    (interactive)
    (when (table-cell-p)
      (-let* ((cells (table-row-cells))
              ((ftl . fbr) (-first-item cells))
              ((ltl . lbr) (-last-item cells)))
        (table--goto-coordinate ftl)
        (when extend-top
          (previous-line))
        (when extend-left
          (backward-char))
        (rectangle-mark-mode 1)
        (table--goto-coordinate lbr)
        (when extend-right
          (forward-char))
        (when extend-bottom
          (next-line)))))

  (cl-defun table-mark-column (&key
                                 extend-top
                                 extend-left
                                 extend-right
                                 extend-bottom)
    (interactive)
    (when (table-cell-p)
      (-let* ((cells (table-column-cells))
              ((ftl . fbr) (-first-item cells))
              ((ltl . lbr) (-last-item cells)))
        (table--goto-coordinate ftl)
        (when extend-top
          (previous-line))
        (when extend-left
          (backward-char))
        (rectangle-mark-mode 1)
        (table--goto-coordinate lbr)
        (when extend-right
          (forward-char))
        (when extend-bottom
          (next-line)))))


  (cl-defun table-mark-row-for-kill ()
    (when (table-cell-p)
      (-let* ((cells (table-row-cells))
              ((ftl . fbr) (-first-item cells))
              ((ltl . lbr) (-last-item cells)))
        (table--goto-coordinate ftl)
        (previous-line)
        (backward-char)
        (set-mark (point))
        (table--goto-coordinate lbr)
        (end-of-line)
        (forward-char))))

  (cl-defun table-mark-column-for-kill ()
    (when (table-cell-p)
      (-let* ((cells (table-column-cells))
              ((ftl . fbr) (-first-item cells))
              ((ltl . lbr) (-last-item cells)))
        (table--goto-coordinate ftl)
        (previous-line)
        (backward-char)
        (rectangle-mark-mode 1)
        (table--goto-coordinate lbr)
        (rectangle-next-line))))

  (defun table-kill-row ()
    (interactive)
    (when (table-cell-p)
      (table-save-vertical
       (table-save-horizontal
        (table-mark-row-for-kill)
        (call-interactively 'kill-region)))))

  (defun table-kill-column ()
    (interactive)
    (table-save-horizontal
     (table-save-vertical
      (table-mark-column-for-kill)
      (call-interactively 'kill-region))))


  (defun table-row-up ()
    (interactive)
    (when (and (table-cell-p) (not (table-first-row-p)))
      (let ((last-p (table-last-row-p)))
        (table-save-vertical
         (table-save-horizontal
          (table-kill-row)
          (unless last-p
            (search-backward-regexp "^\\+"))
          (search-backward-regexp "^\\+")
          (beginning-of-line)
          (call-interactively 'yank)))
        (when (not (table-first-row-p))
          (call-interactively 'table-go-up)))))


  ;; (defun table-row-down ()
  ;;   (interactive)
  ;;   (when (and (table-cell-p) (not (table-last-row-p)))
  ;;     (table-save-vertical
  ;;      (table-save-horizontal
  ;;       (table-kill-row)
  ;;       (search-forward-regexp "^\\+")
  ;;       (beginning-of-line)
  ;;       (call-interactively 'yank)))
  ;;     (when (not (table-last-row-p))
  ;;       (call-interactively 'table-go-down))))

  (defun table-row-down ()
    (interactive)
    (when (and (table-cell-p) (not (table-last-row-p)))
      (table-save-vertical
       (table-save-horizontal
        (table-kill-row)
        (search-forward-regexp "^\\+")
        (beginning-of-line)
        (call-interactively 'yank)))
      (when (not (table-last-row-p))
        (call-interactively 'table-go-down))))

  (defun table-column-left ()
    (interactive)
    (when (and (table-cell-p) (not (table-first-column-p)))
      (let ((last-p (table-last-column-p)))
        (table-save-vertical
         (table-save-horizontal
          (table-kill-column)
          (unless last-p
            (table-go-left))
          (table-goto-first-row)
          (previous-line)
          (backward-char)
          (call-interactively 'yank)))
        (table-go-left))))

  (defun table-column-right ()
    (interactive)
    (when (and (table-cell-p) (not (table-last-column-p)))
      (table-save-horizontal
       (table-save-vertical
        (table-kill-column)
        (if (table-last-column-p)
            (progn
              (end-of-line)
              (while (< 1 (line-number-at-pos))
                (previous-line)))
          (table-go-right)
          (table-goto-first-row)
          (previous-line))
        (backward-char)
        (call-interactively 'yank)))
      (unless (table-last-column-p)
        (table-go-right))))



  (:hydra episteme-hydra-text (:color red :major-mode text-mode)
    ("Move"
     (("j" table-go-down "go down")
      ("k" table-go-up "go up")
      ("h" table-go-left "go left")
      ("l" table-go-right "go right"))
     "Table size"
     (("<" table-narrow-cell "narrow cell")
      (">" table-widen-cell "widen cell")
      ("{" table-shorten-cell "shorten cell")
      ("}" table-heighten-cell "heighten cell"))
     "Table justify"
     (("c" table-justify-cell "justify cell")
      ("C" table-justify-column "justify column")
      ("r" table-justfy-row "justify row"))
     "Table insert"
     (("i" table-insert-row "insert row")
      ("I" table-insert-column "insert column"))
     "Table delete"
     (("d" table-kill-row "delete row")
      ("D" table-kill-column "delete column"))
     "Table move"
     (("J" table-row-down "row down")
      ("K" table-row-up "row up")
      ("H" table-column-left "column left")
      ("L" table-column-right "column right"))))
#+end_src

** hydra-elisp
#+begin_src emacs-lisp
  (:hydra episteme-hydra-elisp (:color blue :major-mode emacs-lisp-mode)
    ("Execute"
     (("d" eval-defun "defun")
      ("b" eval-current-buffer "buffer")
      ("r" eval-region "region"))
     "Debug"
     (("D" edebug-defun "defun")
      ("a" edebug-all-defs "all definitions" :color red)
      ("A" edebug-all-forms "all forms" :color red)
      ("x" macrostep-expand "expand macro"))))
#+end_src

** hydra-org
*** hydra-org-goto-first-sibling
#+begin_src emacs-lisp
  (defun hydra-org-goto-first-sibling () (interactive)
         (org-backward-heading-same-level 99999999))
#+end_src

*** hydra-org-goto-last-sibling
#+begin_src emacs-lisp
  (defun hydra-org-goto-last-sibling () (interactive)
         (org-forward-heading-same-level 99999999))
#+end_src

*** hydra-org-parent-level
#+begin_src emacs-lisp
  (defun hydra-org-parent-level ()
    (interactive)
    (let ((o-point (point)))
      (if (save-excursion
            (beginning-of-line)
            (looking-at org-heading-regexp))
          (progn
            (call-interactively 'outline-up-heading)
            (org-cycle-internal-local))
        (progn
          (call-interactively 'org-previous-visible-heading)
          (org-cycle-internal-local)))
      (when (and (/= o-point (point))
                 org-tidy-p)
        (call-interactively 'hydra-org-tidy))))

 #+end_src

*** hydra-org-child-level
#+begin_src emacs-lisp
  (defun hydra-org-child-level ()
    (interactive)
    (org-show-entry)
    (org-show-children)
    (when (not (org-goto-first-child))
      (when (save-excursion
              (beginning-of-line)
              (looking-at org-heading-regexp))
        (next-line))))
#+end_src

*** hydra-org
 #+begin_src emacs-lisp
   (:hydra episteme-hydra-org (:color amaranth :major-mode org-mode)
     ("Shift"
      (
       ("H" org-promote-subtree "promote")
       ("L" org-demote-subtree "demote")
       ("J" org-move-subtree-down "down")
       ("K" org-move-subtree-up "up")
       )

      "Travel"
      (
       ("h" hydra-org-parent-level "to parent")
       ("l" hydra-org-child-level "to child")
       ("j" org-forward-heading-same-level "forward")
       ("k" org-backward-heading-same-level "backward")
       ("a" hydra-org-goto-first-sibling "first sibling")
       ("e" hydra-org-goto-last-sibling "last sibling")
       )

      "Perform"
      (
       ("t" (org-babel-tangle) "tangle" :color blue)
       ("e" (org-html-export-to-html) "export" :color blue)
       ("b" helm-org-in-buffer-headings "browse")
       ("r" (lambda () (interactive)
              (helm-org-rifle-current-buffer)
              (org-cycle)
              (org-cycle))
        "rifle")
       ("w" helm-org-walk "walk")
       ("v" avy-org-goto-heading-timer "avy")
       ("L" org-toggle-link-display "toggle links")
       ("i" (org-id-get-create) "check id")
       )
      ))
#+end_src

* startup
#+begin_src emacs-lisp
  (episteme/bind-keys)
  (episteme:init-remotes)
  (call-interactively 'episteme:dashboard)
#+end_src
* user config.el
This should remain at the end of this file.
#+begin_src emacs-lisp
  (unless (file-exists-p episteme/config)
    (with-temp-file episteme/config
      (insert ";; this is your custom configuration for episteme,
  ;; you can manage it with orgmode by un-commenting
  ;; the following:
  ;;
  ;; (org-babel-load-file
  ;;  (expand-file-name
  ;;  \"README.org\"
  ;;  episteme/home))

  (provide 'config)
  ;;;config.el ends here")))

  (when (file-exists-p episteme/config)
      (message "Loading user config from: %s" episteme/config)
      (load-file episteme/config))
#+end_src

#+begin_src emacs-lisp
  (run-hooks 'episteme-after-load-hook)
#+end_src
