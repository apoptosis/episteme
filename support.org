#+title: Support.org
#+startup: overview align
#+babel: :cache no
#+Options: ^:nil num:nil tags:nil
#+PROPERTY: header-args    :tangle yes


The following Emacs configuration will allow one to use our knowledge-base
comfortably. You do not need to use the configuration as exactly provided
here. Feel free to take parts and integrate it into your own
configuration.

That said this configuration ought to work out of the box.


* globals
#+begin_src emacs-lisp
  (setq episteme/repo (getenv "repo"))
  (setq episteme/home (getenv "config"))
  (setq episteme/config (concat episteme/home "/config.el"))
  (setq episteme/org (concat episteme/repo "/org"))
  (setq episteme/autosaves (concat episteme/home "/autosaves"))
  (setq episteme/backups (concat episteme/home "/backups"))

  (setq episteme/main-menu-key "C-c x")
  (setq episteme/mode-menu-key "C-c m")
  (setq episteme/zoom 1)

  (unless (file-exists-p episteme/home)
    (make-directory episteme/home))

  (unless (file-exists-p episteme/config)
    (with-temp-file episteme/config
      (insert "
  ;; keybind for default menu
  (setq episteme/default-hydra \"C-c x\")

  ;; keybind for major-mode menu
  (setq episteme/modal-hydra \"C-c m\")

  ;; defaut zoom level
  (setq episteme/zoom 1)
  ")))

  (when (file-exists-p episteme/config)
      (message "Loading config from: %s" episteme/config)
      (load-file episteme/config))

  (setq org-directory episteme/org)
  (setq user-emacs-directory episteme/home)
#+end_src

* bootstrap

The following sections take care of bootstrapping =straight.el= for
package-management and some other concerns before things can get started.

** lexical binding

This line controls how the elisp scoping works in the rest of the file. Lexical
binding is explained in the Emacs documentation.

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

** straight.el
[[https://github.com/raxod502/straight.el][straight.el]] is an alternative to [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Packages.html][package.el]] with many advantages including the
ability to integrate with [[https://github.com/jwiegley/use-package][use-package]] and installing packages from git or
github.

*** bootstrap
Run the [[https://github.com/raxod502/straight.el#bootstrapping-straightel][straight.el bootstrap]].
#+begin_src emacs-lisp
  (let ((bootstrap-file (concat user-emacs-directory "/straight/repos/straight.el/bootstrap.el"))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

*** use-package integration
Ensure that =use-package= is [[https://github.com/raxod502/straight.el#integration-with-use-package-1][working with straight.el]]
#+begin_src emacs-lisp
  (setq straight-use-package-by-default t)
  (straight-use-package 'use-package)
  (use-package git) ;; ensure we can install from git sources
#+end_src

** general dependencies

The following package dependencies are used throughout the rest of the
configuration. They provide contemporary APIs for working with various elisp
data structures.

#+begin_src emacs-lisp
  (require 'cl-lib)
  (use-package f :demand t)          ;; files
  (use-package dash :demand t)       ;; lists
  (use-package ht :demand t)         ;; hash-tables
  (use-package s :demand t)          ;; strings
  (use-package a :demand t)          ;; association lists
  (use-package anaphora :demand t)   ;; anaphora
#+end_src

* helpers
These macros are conveinent shorthands.

** :function
Make non-interactive functions out of forms or a symbol.

e.g. =(:function (message "Hello world.")=
e.g. =(:function foobar)=

#+begin_src emacs-lisp
  (defmacro :function (&rest body)
    (if (->> body length (< 1))
        `(lambda () ,@body)
      (pcase (car body)
        ;; command symbol
        ((and v (pred commandp))
         `(lambda () (call-interactively (quote ,v))))
        ;; function symbol
        ((and v (pred symbolp))
         `(lambda () (,v)))
        ;; quoted command symbol
        ((and v (pred consp) (guard (eq 'quote (car v))) (pred commandp (cadr v)))
         `(lambda () (call-interactively ,v)))
        ;; quoted function symbol
        ((and v (pred consp) (guard (eq 'quote (car v))))
         `(lambda () (,(cadr v))))
        ;; body forms
        (_ `(lambda () ,@body) ))))
#+end_src

** :command
Make interactive commands out of forms or a symbol.

e.g. =(:command (message "Hello world."))=
e.g. =(:command foobar)=

#+begin_src emacs-lisp
  (defmacro :command (&rest body)
    (if (->> body length (< 1))
        `(lambda () (interactive) ,@body)
      (pcase (car body)
        ;; command symbol
        ((and v (pred commandp))
         `(lambda () (interactive) (call-interactively (quote ,v))))
        ;; function symbol
        ((and v (pred symbolp))
         `(lambda () (interactive) (,v)))
        ;; quoted command symbol
        ((and v (pred consp) (guard (eq 'quote (car v))) (pred commandp (cadr v)))
         `(lambda () (interactive) (call-interactively ,v)))
        ;; quoted function symbol
        ((and v (pred consp) (guard (eq 'quote (car v))))
         `(lambda () (interactive) (,(cadr v))))
        ;; body forms
        (_ `(lambda () (interactive) ,@body) ))))
#+end_src

** :after
Defer some forms until the given package is loaded.

e.g. =(:after org (message "Hello world"))=

#+begin_src emacs-lisp
  (defmacro :after (package &rest body)
    "A simple wrapper around `with-eval-after-load'."
    (declare (indent defun))
    `(with-eval-after-load ',package ,@body))
#+end_src

** :hook
Register some forms or a symbol with a hook.

e.g. =(:hook org-mode (message "hello world")=
e.g. (:hook org-mode foobar)

#+begin_src emacs-lisp
  (defmacro :hook (hook-name &rest body)
    "A simple wrapper around `add-hook'"
    (declare (indent defun))
    (let* ((hook-name (format "%s-hook" (symbol-name hook-name)))
           (hook-sym (intern hook-name))
           (first (car body))
           (local (eq :local first))
           (body (if local (cdr body) body))
           (first (car body))
           (body (if (consp first)
                     (if (eq (car first) 'quote)
                         first
                       `(lambda () ,@body))
                   `',first)))
      `(add-hook ',hook-sym ,body nil ,local)))
#+end_src

** :push
A wrapper around help:add-to-list.

e.g. =(:push some-list 1 2 3)=

#+begin_src emacs-lisp
  (defmacro :push (sym &rest body)
    (declare (indent defun))
    (if (consp body)
        `(setq ,sym (-snoc ,sym ,@body))
      `(add-to-list ,sym ,body)))
#+end_src

** :bind
Bind some forms or a symbol to a key.

e.g. =(:bind "C-m" (message "Hello world."=
e.g. =(:bind org-mode "C-m" (message "Hello world."))=

#+begin_src emacs-lisp
  (defmacro :bind (key &rest body)
    (declare (indent defun))
    (pcase key
      ;; kbd string resolving symbol
      ((and k (pred symbolp) (pred boundp) (guard (stringp (eval key))))
       `(global-set-key (kbd ,(eval key)) ,(eval `(:command ,@body))))
      ;; partial mode symbol
      ((pred symbolp)
       (let ((mode (intern (format "%s-map" key)))
             (key (eval (car body)))
             (body (eval `(:command ,@(cdr body)))))
         `(define-key ,mode (kbd ,key) ,body)))
      ;; global binding
      (_ `(global-set-key (kbd ,key) ,(eval `(:command ,@body))))))
#+end_src

* keybinds
#+begin_src emacs-lisp
  (:bind "C-x g" magit-status)
  (:bind episteme/main-menu-key (hera-start 'episteme-hydra-default/body))
  (:bind episteme/mode-menu-key episteme:hydra-dwim)
#+end_src

* dashboard
#+begin_src emacs-lisp
  (use-package dashboard
    :ensure t
    :config
    (setq dashboard-banner-logo-title "apoptosis/episteme")
    (setq dashboard-startup-banner (concat episteme/repo "/cain.png"))
    (setq dashboard-footer-messages
          '("Co-edification through tinkering, dialectic and reference!"))
    ;; (setq dashboard-footer-icon (all-the-icons-octicon "dashboard"
    ;;                                                    :height 1.1
    ;;                                                    :v-adjust -0.05
    ;;                                                    :face 'font-lock-keyword-face))
    (setq dashboard-center-content t)
    (setq dashboard-items '((recents . 20)))
    (dashboard-setup-startup-hook))
  
  (defun episteme:dashboard ()
    "Jump to the dashboard buffer, if doesn't exists create one."
    (interactive)
    (switch-to-buffer dashboard-buffer-name)
    (dashboard-mode)
    (dashboard-insert-startupify-lists)
    (dashboard-refresh-buffer))
#+end_src

* aesthetics
** vertical border
Make the border between windows visible.

#+begin_src emacs-lisp
  (set-face-foreground 'vertical-border "gray")
#+end_src

** blend in the fringes
Hide the default buffer margins.

#+begin_src emacs-lisp
  (set-face-attribute 'fringe nil :background nil)
#+end_src

** column number
Show column number in addition to line number.

#+begin_src emacs-lisp
  (column-number-mode 1)
#+end_src

** doom modeline
Use [[https://github.com/seagle0128/doom-modeline][doom-modeline]] to ornament the modeline.

#+begin_src emacs-lisp
  (use-package doom-modeline
    :ensure t
    :config
    (doom-modeline-def-modeline
     'my-modeline

     '(bar workspace-name window-number modals matches buffer-info remote-host selection-info)
     '(objed-state misc-info buffer-position major-mode process vcs checker))

    (doom-modeline-mode 1)
    (setq doom-modeline-height 35)
    (setq doom-modeline-bar-width 5)
    :init
    (defun setup-custom-doom-modeline ()
      (doom-modeline-set-modeline 'my-modeline 'default))
    (:hook doom-modeline-mode 'setup-custom-doom-modeline))
#+end_src

** doom theme
#+begin_src emacs-lisp
  (use-package doom-themes
    :ensure t
    :config
    ;; Global settings (defaults)
    (setq doom-themes-enable-bold t     ; if nil, bold is universally disabled
          doom-themes-enable-italic t)  ; if nil, italics is universally disabled
    (load-theme (intern (format "doom-%s" (or (getenv "theme") "laserwave"))) t)

    ;; Enable flashing mode-line on errors
    (doom-themes-visual-bell-config)
    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config))
#+end_src

* core settings
** autosaves
Periodically save a copy of open files.

*** autosave every file buffer
#+begin_src emacs-lisp
  (setq auto-save-default t)
#+end_src

*** save every 20 secs or 20 keystrokes
#+begin_src emacs-lisp
  (setq auto-save-timeout 20
        auto-save-interval 20)
#+end_src

*** keep autosaves in a single place
#+begin_src emacs-lisp
  (unless (file-exists-p episteme/autosaves)
      (make-directory episteme/autosaves))

  (setq auto-save-file-name-transforms
        `((".*" ,episteme/autosaves t)))
#+end_src

** backups
Backups are created everytime a buffer is manually saved.

*** backup every save
#+begin_src emacs-lisp
  (use-package backup-each-save
    :config (:hook after-save backup-each-save))
#+end_src

*** keep 10 backups
#+begin_src emacs-lisp
  (setq kept-new-versions 10)
#+end_src

*** delete old backups
#+begin_src emacs-lisp
  (setq delete-old-versions t)
#+end_src

*** copy files to avoid various problems
#+begin_src emacs-lisp
  (setq backup-by-copying t)
#+end_src

*** backup files even if version controlled
#+begin_src emacs-lisp
  (setq vc-make-backup-files t)
#+end_src

*** keep backups in a single place
#+begin_src emacs-lisp
  (unless (file-exists-p episteme/backups)
    (make-directory episteme/backups))

  (setq backup-directory-alist
        `((".*" . ,episteme/backups)))

  (setq make-backup-files t)
#+end_src

** cursor
*** box style
#+begin_src emacs-lisp
  (setq-default cursor-type 'box)
#+end_src

*** blinking
#+begin_src emacs-lisp
  (blink-cursor-mode 1)
#+end_src

** disable
Disable various UI and other features for a more minimal
experience.

*** menubar
#+begin_src emacs-lisp
  (menu-bar-mode -1)
#+end_src

*** toolbar
#+begin_src emacs-lisp
  (tool-bar-mode -1)
#+end_src

*** scrollbar
#+begin_src emacs-lisp
  (scroll-bar-mode -1)
#+end_src

*** startup message
#+begin_src emacs-lisp
  (setq inhibit-startup-message t
        initial-scratch-message nil)
#+end_src

*** customizations file
Disable the customizations file so there's no temptation to use the
customization interface.

#+begin_src emacs-lisp
  (setq custom-file (make-temp-file ""))
#+end_src

** editing
*** use spaces
#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src
*** global visual line wrap
#+begin_src emacs-lisp
  (global-visual-line-mode 1)
#+end_src
*** wrap lines at 79 characters
#+begin_src emacs-lisp
  (setq-default fill-column 79)
#+end_src

*** autowrap in text-mode
#+begin_src emacs-lisp
  ;; (:hook text-mode 'turn-on-auto-fill)
#+end_src

*** ssh for tramp
Default method for transferring files with Tramp.

#+begin_src emacs-lisp
  (setq tramp-default-method "ssh")
#+end_src

** minor-modes
*** whitespace-mode
Visually display trailing whitespace

#+begin_src emacs-lisp
  (use-package whitespace
    :custom
    (whitespace-style
     '(face tabs newline trailing tab-mark space-before-tab space-after-tab))
    :config
    (global-whitespace-mode 1))
#+end_src

*** prettify-symbols-mode
Replace various symbols with nice looking unicode glyphs.

#+begin_src emacs-lisp
  (global-prettify-symbols-mode 1)
#+end_src

*** electric-pair-mode
Automatically insert matching close-brackets for any open bracket.

#+begin_src emacs-lisp
  (electric-pair-mode 1)
#+end_src

*** rainbow-delimeters-mode
Color parenthesis based on their depth, using the golden ratio (because why
not).

#+begin_src emacs-lisp
  (require 'color)
  (defun gen-col-list (length s v &optional hval)
    (cl-flet ( (random-float () (/ (random 10000000000) 10000000000.0))
            (mod-float (f) (- f (ffloor f))) )
      (unless hval
        (setq hval (random-float)))
      (let ((golden-ratio-conjugate (/ (- (sqrt 5) 1) 2))
            (h hval)
            (current length)
            (ret-list '()))
        (while (> current 0)
          (setq ret-list
                (append ret-list
                        (list (apply 'color-rgb-to-hex (color-hsl-to-rgb h s v)))))
          (setq h (mod-float (+ h golden-ratio-conjugate)))
          (setq current (- current 1)))
        ret-list)))

  (defun set-random-rainbow-colors (s l &optional h)
    ;; Output into message buffer in case you get a scheme you REALLY like.
    ;; (message "set-random-rainbow-colors %s" (list s l h))
    (interactive)
    (rainbow-delimiters-mode t)

    ;; Show mismatched braces in bright red.
    (set-face-background 'rainbow-delimiters-unmatched-face "red")

    ;; Rainbow delimiters based on golden ratio
    (let ( (colors (gen-col-list 9 s l h))
           (i 1) )
      (let ( (length (length colors)) )
        ;;(message (concat "i " (number-to-string i) " length " (number-to-string length)))
        (while (<= i length)
          (let ( (rainbow-var-name (concat "rainbow-delimiters-depth-" (number-to-string i) "-face"))
                 (col (nth i colors)) )
            ;; (message (concat rainbow-var-name " => " col))
            (set-face-foreground (intern rainbow-var-name) col))
          (setq i (+ i 1))))))

  (use-package rainbow-delimiters :commands rainbow-delimiters-mode :hook ...
    :init
    (setq rainbow-delimiters-max-face-count 16)
    (set-random-rainbow-colors 0.6 0.7 0.5)
    (:hook prog-mode 'rainbow-delimiters-mode))
#+end_src

*** show-paren-mode
Highlight the matching open or closing bracket.

#+begin_src emacs-lisp
  (require 'paren)
  (show-paren-mode 1)
  (setq show-paren-delay 0)
  (:after xresources
    (set-face-foreground 'show-paren-match (theme-color 'green))
    (set-face-foreground 'show-paren-mismatch "#f00")
    (set-face-attribute 'show-paren-match nil :weight 'extra-bold)
    (set-face-attribute 'show-paren-mismatch nil :weight 'extra-bold))
#+end_src

*** which-key-mode
Show possible followups after pressing a key prefix.

#+begin_src emacs-lisp
  (use-package which-key
    :custom
    ;; sort single chars alphabetically P p Q q
    (which-key-sort-order 'which-key-key-order-alpha)
    (which-key-idle-delay 0.4)
    :config
    (which-key-mode))
#+end_src

*** company-mode
Show popup autocompletion.

#+begin_src emacs-lisp
  (use-package company
    :config
    (global-company-mode))
#+end_src

** shorten prompts
Shorten yes/no prompts to one letter.

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** visual
** zoom
Adjust font size in buffers or globally.

#+begin_src emacs-lisp
  (use-package zoom-frm
    :straight (zoom-frm :type git
                        :host github
                        :repo "emacsmirror/zoom-frm")
    :config
    (dotimes (i episteme/zoom) (zoom-frm-in)))
#+end_src

** cache
This speeds up help:unicode-fonts-setup after first run.

#+begin_src emacs-lisp
  (use-package persistent-soft)
#+end_src

** eval depth
Avoid elision (...) in messages.

#+begin_src emacs-lisp
  (setq print-level 100
        print-length 9999
        eval-expression-print-level 100
        eval-expression-print-length 9999)
#+end_src

** debug on error
Show tracebacks when errors happen.

#+begin_src emacs-lisp
  (setq debug-on-error t)
#+end_src

* helpful
Alternative to the built-in Emacs help that provides much more contextual
information.

#+begin_src emacs-lisp
  (use-package helpful
      :straight (helpful :type git :host github :repo "Wilfred/helpful")
      :bind (("C-h s" . #'helpful-symbol)
             ("C-h c" . #'helpful-command)
             ("C-h f" . #'helpful-function)
             ("C-h v" . #'helpful-variable)
             ("C-h k" . #'helpful-key)
             ("C-h m" . #'helpful-mode)
             ("C-h C-h" . #'helpful-at-point)))
#+end_src

** contextual help
*** toggle-context-help
#+begin_src emacs-lisp
  (defun toggle-context-help ()
    "Turn on or off the context help.
  Note that if ON and you hide the help buffer then you need to
  manually reshow it. A double toggle will make it reappear"
    (interactive)
    (with-current-buffer (help-buffer)
      (unless (local-variable-p 'context-help)
        (set (make-local-variable 'context-help) t))
      (if (setq context-help (not context-help))
          (progn
             (if (not (get-buffer-window (help-buffer)))
                 (display-buffer (help-buffer)))))
      (message "Context help %s" (if context-help "ON" "OFF"))))
#+end_src

*** context-help
#+begin_src emacs-lisp
  (defun context-help ()
    "Display function or variable at point in *Help* buffer if visible.
  Default behaviour can be turned off by setting the buffer local
  context-help to false"
    (interactive)
    (let ((rgr-symbol (symbol-at-point))) ; symbol-at-point http://www.emacswiki.org/cgi-bin/wiki/thingatpt%2B.el
      (with-current-buffer (help-buffer)
       (unless (local-variable-p 'context-help)
         (set (make-local-variable 'context-help) t))
       (if (and context-help (get-buffer-window (help-buffer))
           rgr-symbol)
         (if (fboundp  rgr-symbol)
             (describe-function rgr-symbol)
           (if (boundp  rgr-symbol) (describe-variable rgr-symbol)))))))
#+end_src

*** advise symbol eldoc
#+begin_src emacs-lisp
  (defadvice eldoc-print-current-symbol-info
    (around eldoc-show-c-tag activate)
    (cond
          ((eq major-mode 'emacs-lisp-mode) (context-help) ad-do-it)
          ((eq major-mode 'lisp-interaction-mode) (context-help) ad-do-it)
          ((eq major-mode 'apropos-mode) (context-help) ad-do-it)
          (t ad-do-it)))
#+end_src

* languages
** lispy-mode
#+begin_src emacs-lisp
  (use-package lispy
    :init
    (:hook emacs-lisp-mode (lispy-mode 1))
    (:hook lisp-interaction-mode (lispy-mode 1))
    :config
    (:bind lispy-mode ":" self-insert-command)
    (:bind lispy-mode "[" lispy-open-square)
    (:bind lispy-mode "]" lispy-close-square))
#+end_src
** json-mode
#+begin_src emacs-lisp
  (use-package json-mode
    :straight (json-mode :type git
                         :host github
                         :repo "kiennq/json-mode"
                         :branch "feat/jsonc-mode")
    :config
    (setf auto-mode-alist (assoc-delete-all "\\(?:\\(?:\\.\\(?:b\\(?:\\(?:abel\\|ower\\)rc\\)\\|json\\(?:ld\\)?\\)\\|composer\\.lock\\)\\'\\)"
                                            auto-mode-alist))
    (setf auto-mode-alist (assoc-delete-all "\\.json\\'" auto-mode-alist))
    (add-to-list 'auto-mode-alist '("\\.json\\'" . jsonc-mode)))
#+end_src

* helm
Menu and selection framework for finding files, switching buffers, running
grep, etc. A number of Episteme features are built ontop of Helm.

#+begin_src emacs-lisp
  (use-package helm
    :config
    (helm-mode 1)
    (require 'helm-config)
    (:bind "M-x" helm-M-x)
    (:bind "C-x C-f" helm-find-files)
    (:bind "C-x b" helm-mini)
    (:bind "C-c y" helm-show-kill-ring)
    (:bind "C-x C-r" helm-recentf))
#+end_src
** ace jump
Quickly jump to any candidate with a short letter combo.

#+begin_src emacs-lisp
  (use-package ace-jump-helm-line
    :config
    (:bind helm "C-;" ace-jump-helm-line))
#+end_src

** helm-ag
#+begin_src emacs-lisp
  (use-package helm-ag)
#+end_src

** helm-descbinds
Use (=C-h b= / =kbd-helm-descbinds=) to inspect current bindings with Helm.

#+begin_src emacs-lisp
  (use-package helm-descbinds
    :commands helm-descbinds
    :config
    (:bind "C-h b" helm-descbinds))
#+end_src

** auto full frame
Make Helm always full height.

#+begin_src emacs-lisp
  (defvar helm-full-frame-threshold 0.75)

  (when window-system
    (defun helm-full-frame-hook ()
    (let ((threshold (* helm-full-frame-threshold (x-display-pixel-height))))
      (setq helm-full-frame (< (frame-height) threshold))))

    (:hook helm-before-initialize 'helm-full-frame-hook))
#+end_src

* magit
The best git frontend there is.

#+begin_src emacs-lisp
  (use-package magit)
#+end_src
* org-mode
A souped up markup with tasking, scheduling and aggregation features.

** straight.el fixes
Fix some issues with straight.el and org until [[https://github.com/raxod502/straight.el#installing-org-with-straightel][that is resolved]].

*** fix-org-git-version
#+begin_src emacs-lisp
  (defun fix-org-git-version ()
    "The Git version of org-mode.
    Inserted by installing org-mode or when a release is made."
    (require 'git)
    (let ((git-repo (expand-file-name
                     "straight/repos/org/" user-emacs-directory)))
      (string-trim
       (git-run "describe"
                "--match=release\*"
                "--abbrev=6"
                "HEAD"))))
#+end_src

*** fix-org-release
#+begin_src emacs-lisp
  (defun fix-org-release ()
    "The release version of org-mode.
    Inserted by installing org-mode or when a release is made."
    (require 'git)
    (let ((git-repo (expand-file-name
                     "straight/repos/org/" user-emacs-directory)))
      (string-trim
       (string-remove-prefix
        "release_"
        (git-run "describe"
                 "--match=release\*"
                 "--abbrev=0"
                 "HEAD")))))
#+end_src

** installation
#+begin_src emacs-lisp
  (use-package org
    :config
    ;; these depend on the 'straight.el fixes' above
    (defalias #'org-git-version #'fix-org-git-version)
    (defalias #'org-release #'fix-org-release)
    (require 'org-habit)
    (require 'org-indent)
    (require 'org-capture)
    (require 'org-tempo)
    (add-to-list 'org-modules 'org-habit t))
#+end_src

** look
*** theme customizations
#+begin_src emacs-lisp
  (when window-system
    (use-package org-beautify-theme
      :after (org)
      :config
      (setq org-fontify-whole-heading-line t)
      (setq org-fontify-quote-and-verse-blocks t)
      (setq org-hide-emphasis-markers t)
      (cl-loop for (face . spec) in
       `((org-document-title .
          ((t (:inherit org-level-1 :height 2.0 :underline nil :box nil))))
         (org-level-1 . ((t (:height 1.5 :box nil))))
         (org-level-2 . ((t (:height 1.25 :box nil))))
         (org-level-3 . ((t (:box nil))))
         (org-level-4 . ((t (:box nil))))
         (org-level-5 . ((t (:box nil))))
         (org-level-6 . ((t (:box nil))))
         (org-level-7 . ((t (:box nil))))
         (org-level-8 . ((t (:box nil))))
         (org-link . ((t (:underline t)))))
       do (face-spec-set face spec))))
#+end_src

*** pretty symbols
Add a hook to set the pretty symbols alist.

#+begin_src emacs-lisp
  (setq episteme/pretty-symbols nil)
  (:hook org-mode
    (setq-local prettify-symbols-alist episteme/pretty-symbols))
#+end_src
*** indent by header level
Hide the heading asterisks. Instead indent headings based on depth.

#+begin_src emacs-lisp
  (:hook org-mode 'org-indent-mode)
#+end_src

*** pretty heading bullets
Use nice unicode bullets instead of the default asterisks.

#+begin_src emacs-lisp
  (use-package org-bullets
    :init
    (:hook org-mode 'org-bullets-mode)
    :config
    (setq org-bullets-bullet-list '("‚óâ" "‚óã" "‚ú∏" "‚Ä¢")))
#+end_src

*** pretty priority cookies
Instead of the default =[#A]= and =[#C]= priority cookies, use little unicode arrows to
indicate high and low priority. =[#B]=, which is the same as no priority, is shown as
normal.

#+begin_src emacs-lisp
  (:push episteme/pretty-symbols
    '("[#A]" . "‚áë")
    '("[#C]" . "‚áì"))
#+end_src

#+begin_src emacs-lisp
  ;; only show priority cookie symbols on headings.
  (defun nougat/org-pretty-compose-p (start end match)
    (if (or (string= match "[#A]") (string= match "[#C]"))
        ;; prettify asterisks in headings
        (org-match-line org-outline-regexp-bol)
      ;; else rely on the default function
      (funcall #'prettify-symbols-default-compose-p start end match)))


  (:hook org-mode (setq-local prettify-symbols-compose-predicate
                              #'nougat/org-pretty-compose-p))
#+end_src

*** pretty heading ellipsis
Show a little arrow for collapsed headings.

#+begin_src emacs-lisp
  (:after org
    (setq org-ellipsis " ‚ñø"))
#+end_src

*** prettify source blocks
#+begin_src emacs-lisp
  (:push episteme/pretty-symbols
    '("#+begin_src" . ">>")
    '("#+end_src" . "¬∑"))
#+end_src
*** dynamic tag position
#+begin_src emacs-lisp
  (defun org-realign-tags ()
    (interactive)
    (setq org-tags-column (- 0 (window-width)))
    (org-align-tags t))

  ;; (:hook window-configuration-change 'org-realign-tags)
#+end_src

** feel
*** show all headings on startup
#+begin_src emacs-lisp
  (setq org-startup-folded 'content)
#+end_src

*** don't fold blocks on open
#+begin_src emacs-lisp
  (setq org-hide-block-startup nil)
#+end_src

*** auto-fill paragraphs
#+begin_src emacs-lisp
  (:hook org-mode 'turn-on-auto-fill)
#+end_src

*** resepect content on insert
Don't split existing entries when inserting a new heading.

#+begin_src emacs-lisp
  (setq org-insert-heading-respect-content nil)
#+end_src

*** use helpful for help links
#+begin_src emacs-lisp
  (advice-add 'org-link--open-help :override
              (lambda (path) (helpful-symbol (intern path))))
#+end_src
** todo keywords
*** boilerplate
**** make-state-model
#+begin_src emacs-lisp
  (defun todo-make-state-model (name key props)
    (append (list :name name :key key) props))
#+end_src
**** parse-state-data
#+begin_src emacs-lisp
  (defun todo-parse-state-data (state-data)
    (-let* (((name second &rest) state-data)
            ((key props) (if (stringp second)
                             (list second (cddr state-data))
                           (list nil (cdr state-data)))))
      (todo-make-state-model name key props)))
#+end_src
**** make-sequence-mode
#+begin_src emacs-lisp
  (defun todo-make-sequence-model (states)
    (mapcar 'todo-parse-state-data states))
#+end_src
**** parse-sequences-data
#+begin_src emacs-lisp
  (defun todo-parse-sequences-data (sequences-data)
    (mapcar 'todo-make-sequence-model sequences-data))
#+end_src
**** todo-keyword-name
#+begin_src emacs-lisp
  (defun todo-keyword-name (name key)
    (if key (format "%s(%s)" name key) name))
#+end_src
**** keyword-name-forstate
#+begin_src emacs-lisp
  (defun todo-keyword-name-for-state (state)
    (todo-keyword-name (plist-get state :name)
                       (plist-get state :key)))
#+end_src
**** is-done-state
#+begin_src emacs-lisp
  (defun todo-is-done-state (state)
    (equal t (plist-get state :done-state)))
#+end_src
**** is-not-done-state
#+begin_src emacs-lisp
  (defun todo-is-not-done-state (state)
    (equal nil (plist-get state :done-state)))
#+end_src
**** org-sequence
#+begin_src emacs-lisp
  (defun todo-org-sequence (states)
    (let ((active (seq-filter 'todo-is-not-done-state states))
          (inactive (seq-filter 'todo-is-done-state states)))
      (append '(sequence)
              (mapcar 'todo-keyword-name-for-state active)
              '("|")
              (mapcar 'todo-keyword-name-for-state inactive))))
#+end_src
**** org-todo-keywords
#+begin_src emacs-lisp
  (defun todo-org-todo-keywords (sequences)
    (mapcar 'todo-org-sequence (todo-parse-sequences-data sequences)))
  ;; (todo-org-todo-keywords todo-keywords)
#+end_src
**** org-todo-keyword-faces
#+begin_src emacs-lisp
  (defun todo-org-todo-keyword-faces (sequences)
    (cl-loop for sequence in (todo-parse-sequences-data sequences)
             append (cl-loop for state in sequence
                             for name = (plist-get state :name)
                             for face = (plist-get state :face)
                             collect (cons name face))))
  ;; (todo-org-todo-keyword-faces todo-keywords)
#+end_src
**** prettify-symbols-alist
#+begin_src emacs-lisp
  (defun todo-prettify-symbols-alist (sequences)
    (cl-loop for sequence in (todo-parse-sequences-data sequences)
             append (cl-loop for state in sequence
                             for name = (plist-get state :name)
                             for icon = (plist-get state :icon)
                             collect (cons name icon))))
  ;; (todo-prettify-symbols-alist todo-keywords)
#+end_src
**** finalize-agenda-for-state
#+begin_src emacs-lisp
  (defun todo-finalize-agenda-for-state (state)
    (-let (((&plist :name :icon :face) state))
      (beginning-of-buffer)
      (while (search-forward name nil 1)
        (let* ((line-props (text-properties-at (point)))
               (line-props (org-plist-delete line-props 'face)))
          (call-interactively 'set-mark-command)
          (search-backward name)
          (call-interactively 'kill-region)
          (let ((symbol-pos (point)))
            (insert icon)
            (beginning-of-line)
            (let ((start (point))
                  (end (progn (end-of-line) (point))))
              (add-text-properties start end line-props)
              (add-face-text-property symbol-pos (+ 1 symbol-pos) face))))))
    (beginning-of-buffer)
    (replace-regexp "[[:space:]]+[=]+" ""))
#+end_src

*** keywords
#+begin_src emacs-lisp
  (setq todo-keywords
        ;; normal workflow
        '((("DOING" "d" :icon "üèÉ" :face org-doing-face)
           ("TODO" "t" :icon "‚ñ°‚ÄÑ" :face org-todo-face)
           ("DONE" "D" :icon "‚úì‚ÄÑ" :face org-done-face :done-state t))
          ;; auxillary states
          (("SOON" "s" :icon "‚ùó‚ÄÄ" :face org-soon-face)
           ("SOMEDAY" "S" :icon "üõå" :face org-doing-face)))
        org-todo-keywords (todo-org-todo-keywords todo-keywords)
        org-todo-keyword-faces (todo-org-todo-keyword-faces todo-keywords))

  (--map (:push episteme/pretty-symbols it)
         (todo-prettify-symbols-alist todo-keywords))
#+end_src

*** org agenda finalization
#+begin_src emacs-lisp
  (setq episteme/todo-sequences-data (todo-parse-sequences-data todo-keywords))
  (:hook org-agenda-finalize
    (--each episteme/todo-sequences-data
      (-each it 'todo-finalize-agenda-for-state)))
#+end_src
*** sorting
#+begin_src emacs-lisp
  (defun episteme:todo-sort (a b)
    (let* ((a-state (get-text-property 0 'todo-state a))
           (b-state (get-text-property 0 'todo-state b))
           (a-index (-elem-index a-state todo-keyword-order))
           (b-index (-elem-index b-state todo-keyword-order)))
      (pcase (- b-index a-index)
        ((and v (guard (< 0 v))) 1)
        ((and v (guard (> 0 v))) -1)
        (default nil))))

  (setq org-agenda-cmp-user-defined 'episteme:todo-sort
        todo-keyword-order '("DOING" "SOON" "TODO" "SOMEDAY" "DONE"))
#+end_src

** org-babel
*** babel languages
**** ob-csharp
#+begin_src emacs-lisp
  (use-package ob-csharp
    :straight (ob-csharp :type git
                         :host github
                         :repo "thomas-villagers/ob-csharp"
                         :files ("src/ob-csharp.el"))
    :config
    (:push org-babel-load-languages '(csharp . t)))
#+end_src
**** ob-fsharp
#+begin_src emacs-lisp
  (use-package ob-fsharp
    :straight (ob-fsharp :type git
                         :host github
                         :repo "zweifisch/ob-fsharp"
                         :files ("ob-fsharp.el"))
    :config
    (:push org-babel-load-languages '(fsharp . t)))
#+end_src
*** enable languages
#+begin_src emacs-lisp
  (setq org-babel-load-languages
        '((shell . t)
          (emacs-lisp . t)
          (python . t)
          (js . t)
          (csharp . t)
          (fsharp . t)))
#+end_src

*** default header args
#+begin_src emacs-lisp
  (:after org
    (setq org-babel-default-header-args
          '((:session . "none")
            (:results . "replace")
            (:exports . "code")
            (:cache . "no")
            (:noweb . "no")
            (:hlines . "no")
            (:tangle . "no"))))
#+end_src

*** security
Disable prompts for evaluating org-mode links.
#+begin_src emacs-lisp
  (progn
    (setq org-confirm-babel-evaluate nil)
    (setq org-confirm-elisp-link-function nil)
    (setq org-confirm-shell-link-function nil)
    (setq safe-local-variable-values '((org-confirm-elisp-link-function . nil))))
#+end_src
*** install babel handlers
#+begin_src emacs-lisp
  (:hook after-init
    (org-babel-do-load-languages 'org-babel-load-languages
                                 org-babel-load-languages))
#+end_src

** org-fragtog
Automatically preview LaTex fragments.

#+begin_src emacs-lisp
  (use-package org-fragtog
    :config
    (:hook org-mode 'org-fragtog-mode))
#+end_src

** helm-org
#+begin_src emacs-lisp
  (use-package helm-org)
#+end_src
** helm-org-rifle
Quickly search through the current org buffer.

#+begin_src emacs-lisp
  (use-package helm-org-rifle)
#+end_src
** helm-org-walk
Easily navigate Org files with Helm.
#+begin_src emacs-lisp
  (use-package helm-org-walk
    :straight (helm-org-walk :type git :host github :repo "dustinlacewell/helm-org-walk"))
#+end_src
** org-ql
Query Org files for elements.
#+begin_src emacs-lisp
  (use-package org-ql)
#+end_src
** org-ls
Interact with babel codeblocks from elisp.
#+begin_src emacs-lisp
  (use-package org-ls
    :straight (org-ls :type git :host github :repo "dustinlacewell/org-ls"))
#+end_src
* other packages
** embrace
#+begin_src emacs-lisp
  (use-package embrace
    :config
    (embrace-add-pair (kbd "\;") "`" "`"))
#+end_src

** htmlize
Allows org codeblocks to be syntax highlighted on html export.

#+begin_src emacs-lisp
  (use-package htmlize)
#+end_src

* hydra
[[https://github.com/abo-abo/hydra][Hydra]] provides customizable interactive command palettes.

** pretty-hydra
[[https://github.com/jerrypnz/major-mode-hydra.el#pretty-hydra][Pretty-hydra]] provides a macro that makes it easy to get good looking hydras.

#+begin_src emacs-lisp
  (use-package pretty-hydra
    :demand t
    :straight (pretty-hydra :type git :host github
                            :repo "jerrypnz/major-mode-hydra.el"
                            :files ("pretty-hydra.el")))
#+end_src

** major-mode-hydra
[[https://github.com/jerrypnz/major-mode-hydra.el][Major-mode-hydra]] associates hydras with major-modes.

#+begin_src emacs-lisp
  (use-package major-mode-hydra
    :straight (major-mode-hydra :type git :host github
                                :repo "jerrypnz/major-mode-hydra.el"
                                :files ("major-mode-hydra.el")))
#+end_src

** hera
[[https://github.com/dustinlacewell/hera][Hera]] lets hydras form a stack.

#+begin_src emacs-lisp
  (use-package hera
    :demand t
    :straight (hera :type git :host github :repo "dustinlacewell/hera"))
#+end_src

** :hydra
Macro for defining Hydras.

*** boilerplate
**** inject-hint
#+begin_src emacs-lisp
  (defun :hydra/inject-hint (symbol hint)
    (-let* ((name (symbol-name symbol))
            (hint-symbol (intern (format "%s/hint" name)))
            (format-form (eval hint-symbol))
            (string-cdr (nthcdr 1 format-form))
            (format-string (string-trim (car string-cdr)))
            (amended-string (format "%s\n\n%s" format-string hint)))
      (setcar string-cdr amended-string)))
#+end_src

**** make-head-hint
#+begin_src emacs-lisp
  (defun :hydra/make-head-hint (head default-color)
    (-let (((key _ hint . rest) head))
      (when key
        (-let* (((&plist :color color) rest)
                (color (or color default-color))
                (face (intern (format "hydra-face-%s" color)))
                (propertized-key (propertize key 'face face)))
          (format " [%s]: %s" propertized-key hint)))))
#+end_src

**** make-hint
#+begin_src emacs-lisp
  (defun :hydra/make-hint (heads default-color)
    (string-join
     (cl-loop for head in heads
              for hint = (:hydra/make-head-hint head default-color)
              collect hint) "\n"))
#+end_src

**** clear-hint
#+begin_src emacs-lisp
  (defun :hydra/clear-hint (head)
    (-let* (((key form _ . rest) head))
      `(,key ,form nil ,@rest)))
#+end_src

**** add-exit-head
#+begin_src emacs-lisp
  (defun :hydra/add-exit-head (heads)
    (let ((exit-head '("SPC" (hera-pop) "to exit" :color blue)))
      (append heads `(,exit-head))))
#+end_src

**** add-heads
#+begin_src emacs-lisp
    (defun :hydra/add-heads (columns extra-heads)
      (let* ((cell (nthcdr 1 columns))
             (heads (car cell))
             (extra-heads (mapcar ':hydra/clear-hint extra-heads)))
        (setcar cell (append heads extra-heads))))

#+end_src

*** macro
#+begin_src emacs-lisp
    (defmacro :hydra (name body columns &optional extra-heads)
      (declare (indent defun))
      (-let* (((&plist :color default-color :major-mode mode) body)
              (extra-heads (:hydra/add-exit-head extra-heads))
              (extra-hint (:hydra/make-hint extra-heads default-color))
              (body (plist-put body :hint nil))
              (body-name (format "%s/body" (symbol-name name)))
              (body-symbol (intern body-name))
              (mode-body-name (major-mode-hydra--body-name-for mode))
              (mode-support
               `(when ',mode
                  (defun ,mode-body-name () (interactive) (,body-symbol)))))
        (:hydra/add-heads columns extra-heads)
        (when mode
          (cl-remf body :major-mode))
        `(progn
           (pretty-hydra-define ,name ,body ,columns)
           (:hydra/inject-hint ',name ,extra-hint)
           ,mode-support
           )))
#+end_src

*** tests
#+begin_src emacs-lisp
    ;; (macroexpand-all `(:hydra hydra-test (:color red :major-mode fundamental-mode)
    ;;    ("First"
    ;;     (("a" (message "first - a") "msg a" :color blue)
    ;;      ("b" (message "first - b") "msg b"))
    ;;     "Second"
    ;;     (("c" (message "second - c") "msg c" :color blue)
    ;;      ("d" (message "second - d") "msg d")))))

    ;; (:hydra hydra-test (:color red :major-mode fundamental-mode)
    ;;    ("First"
    ;;     (("a" (message "first - a") "msg a" :color blue)
    ;;      ("b" (message "first - b") "msg b"))
    ;;     "Second"
    ;;     (("c" (message "second - c") "msg c" :color blue)
    ;;      ("d" (message "second - d") "msg d"))))

#+end_src

* main menu
** hydra-help
Many of the Emacs help facilities at your fingertips!

#+begin_src emacs-lisp

  (:hydra episteme-hydra-help (:color blue)
    ("Describe"
     (("c" describe-function "function")
      ("p" describe-package "package")
      ("m" describe-mode "mode")
      ("v" describe-variable "variable"))
     "Keys"
     (("k" describe-key "key")
      ("K" describe-key-briefly "brief key")
      ("w" where-is "where-is")
      ("b" helm-descbinds "bindings"))
     "Search"
     (("a" helm-apropos "apropos")
      ("d" apropos-documentation "documentation")
      ("s" info-lookup-symbol "symbol info"))
     "Docs"
     (("i" info "info")
      ("n" helm-man-woman "man")
      ("h" helm-dash "dash"))
     "View"
     (("e" view-echo-area-messages "echo area")
      ("l" view-lossage "lossage")
      ("c" describe-coding-system "encoding")
      ("I" describe-input-method "input method")
      ("C" describe-char "char at point"))))
#+end_src

** hydra-mark
#+begin_src emacs-lisp
  (defun unpop-to-mark-command ()
    "Unpop off mark ring. Does nothing if mark ring is empty."
    (when mark-ring
      (setq mark-ring (cons (copy-marker (mark-marker)) mark-ring))
      (set-marker (mark-marker) (car (last mark-ring)) (current-buffer))
      (when (null (mark t)) (ding))
      (setq mark-ring (nbutlast mark-ring))
      (goto-char (marker-position (car (last mark-ring))))))

  (defun push-mark ()
    (interactive)
    (set-mark-command nil)
    (set-mark-command nil))

  (:hydra episteme-hydra-mark (:color pink)
    ("Mark"
     (("m" push-mark "mark here")
      ("p" (lambda () (interactive) (set-mark-command '(4))) "previous")
      ("n" (lambda () (interactive) (unpop-to-mark-command)) "next")
      ("c" (lambda () (interactive) (setq mark-ring nil)) "clear"))))
#+end_src

** hydra-registers
#+begin_src emacs-lisp
  (:hydra episteme-hydra-registers (:color pink)
    ("Point"
     (("r" point-to-register "save point")
      ("j" jump-to-register "jump")
      ("v" view-register "view all"))
     "Text"
     (("c" copy-to-register "copy region")
      ("C" copy-rectangle-to-register "copy rect")
      ("i" insert-register "insert")
      ("p" prepend-to-register "prepend")
      ("a" append-to-register "append"))
     "Macros"
     (("m" kmacro-to-register "store")
      ("e" jump-to-register "execute"))))

#+end_src

** hydra-window
#+begin_src emacs-lisp
  (use-package ace-window)
  (winner-mode 1)

  (:hydra episteme-hydra-window (:color red)
    ("Jump"
     (("h" windmove-left "left")
      ("l" windmove-right "right")
      ("k" windmove-up "up")
      ("j" windmove-down "down")
      ("a" ace-select-window "ace"))
     "Split"
     (("q" split-window-right "left")
      ("r" (progn (split-window-right) (call-interactively 'other-window)) "right")
      ("e" split-window-below "up")
      ("w" (progn (split-window-below) (call-interactively 'other-window)) "down"))
     "Do"
     (("d" delete-window "delete")
      ("o" delete-other-windows "delete others")
      ("u" winner-undo "undo")
      ("R" winner-redo "redo")
      ("t" nougat-hydra-toggle-window "toggle"))))
#+end_src

** hydra-zoom
#+begin_src emacs-lisp
  (:hydra episteme-hydra-zoom (:color red)
    ("Buffer"
     (("i" text-scale-increase "in")
      ("o" text-scale-decrease "out"))
     "Frame"
     (("I" zoom-frm-in "in")
      ("O" zoom-frm-out "out")
      ("r" toggle-zoom-frame "reset" :color blue))))
#+end_src

** hydra-dev
#+begin_src emacs-lisp
  (:hydra episteme-hydra-dev (:color blue)
    ("Open"
     (("s" (find-file (concat episteme/repo "/support.org")) "support.org")
      ("d" (find-file (concat episteme/org "/episteme/developer-docs.org")) "docs"))
     "Git"
     (("g" (magit-status) "magit")
      ("p" (magit-pull) "pull")
      ("R" (magit-reset-hard)))))
#+end_src

** hydra-default
#+begin_src emacs-lisp
  (defun episteme:cleanup ()
    (interactive)

    (mapc 'kill-buffer (--filter (not (buffer-modified-p it)) (buffer-list)))
    (delete-other-windows)
    (episteme:dashboard)
    (helm-mini))

  (defun episteme:find-file-all ()
    (interactive)
    (let ((file-name (completing-read "file: "
                                      (directory-files-recursively episteme/org "\.org$"))))
      (find-file file-name)))

  (:hydra episteme-hydra-default (:color blue)
    ("Open"
     (("o" (helm-org-walk '(4)) "open")
      ("a" (episteme:find-file-all) "all files"))
     "Bookmarks"
     (("C" (find-file (concat episteme/org "/episteme/cheatsheet.org")) "Cheatsheet")
      ("U" (find-file (concat episteme/org "/episteme/user-guide.org")) "User guide")
      ("R" (find-file (concat episteme/repo "/README.org")) "README"))
     "Emacs"
     (("h" (hera-push 'episteme-hydra-help/body) "help")
      ("m" (hera-push 'episteme-hydra-mark/body) "mark")
      ("w" (hera-push 'episteme-hydra-window/body) "windows")
      ("z" (hera-push 'episteme-hydra-zoom/body) "zoom")
      ("r" (hera-push 'episteme-hydra-registers/body) "registers"))
     "Misc"
     (("!" (episteme:cleanup) "cleanup windows/buffers")
      ("." (hera-push 'episteme-hydra-dev/body) "devtools")
      (";" embrace-commander "embrace"))))
#+end_src

* mode menus
** boilerplate
*** hydra-dwim
Open hydra for current major mode if one exists, otherwise the default hydra.
#+begin_src emacs-lisp
  (defun episteme:hydra-dwim ()
    (interactive)
    (let* ((mode major-mode)
          (orig-mode mode))
      (catch 'done
        (while mode
          (let ((hydra (major-mode-hydra--body-name-for mode)))
            (when (fboundp hydra)
              (hera-start hydra)
              (throw 'done t)))
          (setq mode (get mode 'derived-mode-parent)))
        (hera-start 'hydra-default/body))))
#+end_src
** hydra-text
#+begin_src emacs-lisp
  (defun wtf ()
    (interactive)
    (table-save-horizontal nil))

  (defun table-cell-p ()
    (table--at-cell-p (point)))

  (defun table-settle-row ()
    (interactive)
    (if (bobp)
        (progn
          (forward-char)
          (next-line))
      (if (eq 1 (line-number-at-pos))
          (if (eq ?- (char-after))
              (next-line)
            (progn
              (backward-char)
              (next-line)))
        (when (eolp)
          (backward-char))
        (while (not (table-cell-p))
          (call-interactively 'previous-line)))))

  (defun table-settle-column ()
    (interactive)
    (if (eq 0 (current-column))
        (forward-char)
      (while (not (table-cell-p))
        (backward-char))))

  (defun table-settle ()
    (interactive)
    (pcase (char-after)
      ((pred (lambda (it) (eq ?- it))) (table-settle-row))
      ((pred (lambda (it) (eq ?| it))) (table-settle-column))
      ((pred (lambda (it) (eq ?+ it))) (progn
                                         (forward-char)
                                         (table-settle-row)))))

  (defun table-row-cells ()
    (table--cell-list-to-coord-list
     (table--horizontal-cell-list t nil 'top)))

  (defun table-column-cells ()
    (table--cell-list-to-coord-list
     (table--vertical-cell-list t nil 'left)))

  (defun table-vertical-index (y cells)
    (--find-index
     (-let* (((tl . br) it)
             ((tlx . tly) tl)
             ((brx . bry) br))
       (and (>= y tly)
            (<= y bry)))
     cells))

  (defun table-horizontal-index (x cells)
    (--find-index
     (-let* (((tl . br) it)
             ((tlx . tly) tl)
             ((brx . bry) br))
       (and (>= x tlx)
            (<= x brx)))
     cells))

  (defun table-get-coordinate ()
    (-let* ((row-cells (table-row-cells))
            (col-cells (table-column-cells))
            ((x . y) (table--get-coordinate))
            (row-index (table-vertical-index y col-cells))
            (col-index (table-horizontal-index x row-cells)))
      (cons col-index row-index)))

  (defun table-first-row-p ()
    (-let* ((cells (table-column-cells))
            ((x . y) (table--get-coordinate))
            (index (table-vertical-index y cells)))
      (eq 0 index)))

  (defun table-last-row-p ()
    (-let* ((cells (table-column-cells))
            ((x . y) (table--get-coordinate))
            (index (table-vertical-index y cells)))
      (eq index (- (length cells) 1))))

  (defun table-first-column-p ()
    (-let* ((cells (table-row-cells))
            ((x . y) (table--get-coordinate))
            (index (table-horizontal-index x cells)))
      (eq 0 index)))

  (defun table-last-column-p ()
    (-let* ((cells (table-row-cells))
            ((x . y) (table--get-coordinate))
            (index (table-horizontal-index x cells)))
      (eq index (- (length cells) 1))))

  (defmacro table-save-vertical (&rest body)
    `(when (table-cell-p)
       (-let* ((cells (table-column-cells))
               ((ox . oy) (table--get-coordinate))
               (index (table-vertical-index oy cells)))
         ,@body
         (table-settle)
         (-let* ((newcells (table-column-cells))
                 (clean-index (max 0 (min (- (length newcells) 1) index)))
                 ((tl . br) (nth clean-index newcells)))
           (table--goto-coordinate tl)
           (table-settle)))))

  (defmacro table-save-horizontal (&rest body)
    `(when (table-cell-p)
       (-let* ((cells (table-row-cells))
               ((ox . oy) (table--get-coordinate))
               (index (table-horizontal-index ox cells)))
         ,@body
         (table-settle)
         (-let* ((newcells (table-row-cells))
                 (clean-index (max 0 (min (- (length newcells) 1) index)))
                 ((tl . br) (nth clean-index newcells)))
           (table--goto-coordinate tl)
           (table-settle)))))

  ;;
  ;; Motion
  ;; 

  (defun table-goto-first-row ()
    (interactive)
    (when (table-cell-p)
      (-let* ((coord-list
               (table--cell-list-to-coord-list
                (table--vertical-cell-list t nil 'left)))
              ((ful . fbr) (car coord-list))
              ((lul . lbr) (-last-item coord-list)))
        (table--goto-coordinate ful))))

  (defun table-go-up ()
    (interactive)
    (when (not (table-first-row-p))
      (-let* ((cells
               (table--cell-list-to-coord-list
                (table--vertical-cell-list t nil 'left)))
              ((ox . oy) (table--get-coordinate))
              (current-index (table-vertical-index oy cells))
              (target-index (- current-index 1))
              ((tl . br) (nth target-index cells)))
        (table--goto-coordinate tl))))

  (defun table-go-down ()
    (interactive)
    (when (not (table-last-row-p))
      (-let* ((cells
               (table--cell-list-to-coord-list
                (table--vertical-cell-list t nil 'left)))
              ((ox . oy) (table--get-coordinate))
              (current-index (table-vertical-index oy cells))
              (target-index (+ current-index 1))
              ((tl . br) (nth target-index cells)))
        (table--goto-coordinate tl))))

  (defun table-go-left ()
    (interactive)
    (when (not (table-first-column-p))
      (-let* ((cells
               (table--cell-list-to-coord-list
                (table--horizontal-cell-list t nil 'left)))
              ((ox . oy) (table--get-coordinate))
              (current-index (table-horizontal-index ox cells))
              (target-index (- current-index 1))
              ((tl . br) (nth target-index cells)))
        (table--goto-coordinate tl))))

  (defun table-go-right ()
    (interactive)
    (when (not (table-last-column-p))
      (-let* ((cells
               (table--cell-list-to-coord-list
                (table--horizontal-cell-list t nil 'top)))
              ((ox . oy) (table--get-coordinate))
              (current-index (table-horizontal-index ox cells))
              (target-index (+ current-index 1))
              ((tl . br) (nth target-index cells)))
        (table--goto-coordinate tl))))

  (cl-defun table-mark-row (&key extend-top
                                 extend-left
                                 extend-right
                                 extend-bottom)
    (interactive)
    (when (table-cell-p)
      (-let* ((cells (table-row-cells))
              ((ftl . fbr) (-first-item cells))
              ((ltl . lbr) (-last-item cells)))
        (table--goto-coordinate ftl)
        (when extend-top
          (previous-line))
        (when extend-left
          (backward-char))
        (rectangle-mark-mode 1)
        (table--goto-coordinate lbr)
        (when extend-right
          (forward-char))
        (when extend-bottom
          (next-line)))))

  (cl-defun table-mark-column (&key
                                 extend-top
                                 extend-left
                                 extend-right
                                 extend-bottom)
    (interactive)
    (when (table-cell-p)
      (-let* ((cells (table-column-cells))
              ((ftl . fbr) (-first-item cells))
              ((ltl . lbr) (-last-item cells)))
        (table--goto-coordinate ftl)
        (when extend-top
          (previous-line))
        (when extend-left
          (backward-char))
        (rectangle-mark-mode 1)
        (table--goto-coordinate lbr)
        (when extend-right
          (forward-char))
        (when extend-bottom
          (next-line)))))


  (cl-defun table-mark-row-for-kill ()
    (when (table-cell-p)
      (-let* ((cells (table-row-cells))
              ((ftl . fbr) (-first-item cells))
              ((ltl . lbr) (-last-item cells)))
        (table--goto-coordinate ftl)
        (previous-line)
        (backward-char)
        (set-mark (point))
        (table--goto-coordinate lbr)
        (end-of-line)
        (forward-char))))

  (cl-defun table-mark-column-for-kill ()
    (when (table-cell-p)
      (-let* ((cells (table-column-cells))
              ((ftl . fbr) (-first-item cells))
              ((ltl . lbr) (-last-item cells)))
        (table--goto-coordinate ftl)
        (previous-line)
        (backward-char)
        (rectangle-mark-mode 1)
        (table--goto-coordinate lbr)
        (rectangle-next-line))))

  (defun table-kill-row ()
    (interactive)
    (when (table-cell-p)
      (table-save-vertical
       (table-save-horizontal
        (table-mark-row-for-kill)
        (call-interactively 'kill-region)))))

  (defun table-kill-column ()
    (interactive)
    (table-save-horizontal
     (table-save-vertical
      (table-mark-column-for-kill)
      (call-interactively 'kill-region))))


  (defun table-row-up ()
    (interactive)
    (when (and (table-cell-p) (not (table-first-row-p)))
      (let ((last-p (table-last-row-p)))
        (table-save-vertical
         (table-save-horizontal
          (table-kill-row)
          (unless last-p
            (search-backward-regexp "^\\+"))
          (search-backward-regexp "^\\+")
          (beginning-of-line)
          (call-interactively 'yank)))
        (when (not (table-first-row-p))
          (call-interactively 'table-go-up)))))


  ;; (defun table-row-down ()
  ;;   (interactive)
  ;;   (when (and (table-cell-p) (not (table-last-row-p)))
  ;;     (table-save-vertical
  ;;      (table-save-horizontal
  ;;       (table-kill-row)
  ;;       (search-forward-regexp "^\\+")
  ;;       (beginning-of-line)
  ;;       (call-interactively 'yank)))
  ;;     (when (not (table-last-row-p))
  ;;       (call-interactively 'table-go-down))))

  (defun table-row-down ()
    (interactive)
    (when (and (table-cell-p) (not (table-last-row-p)))
      (table-save-vertical
       (table-save-horizontal
        (table-kill-row)
        (search-forward-regexp "^\\+")
        (beginning-of-line)
        (call-interactively 'yank)))
      (when (not (table-last-row-p))
        (call-interactively 'table-go-down))))

  (defun table-column-left ()
    (interactive)
    (when (and (table-cell-p) (not (table-first-column-p)))
      (let ((last-p (table-last-column-p)))
        (table-save-vertical
         (table-save-horizontal
          (table-kill-column)
          (unless last-p
            (table-go-left))
          (table-goto-first-row)
          (previous-line)
          (backward-char)
          (call-interactively 'yank)))
        (table-go-left))))

  (defun table-column-right ()
    (interactive)
    (when (and (table-cell-p) (not (table-last-column-p)))
      (table-save-horizontal
       (table-save-vertical
        (table-kill-column)
        (if (table-last-column-p)
            (progn
              (end-of-line)
              (while (< 1 (line-number-at-pos))
                (previous-line)))
          (table-go-right)
          (table-goto-first-row)
          (previous-line))
        (backward-char)
        (call-interactively 'yank)))
      (unless (table-last-column-p)
        (table-go-right))))



  (:hydra episteme-hydra-text (:color red :major-mode text-mode)
    ("Move"
     (("j" table-go-down "go down")
      ("k" table-go-up "go up")
      ("h" table-go-left "go left")
      ("l" table-go-right "go right"))
     "Table size"
     (("<" table-narrow-cell "narrow cell")
      (">" table-widen-cell "widen cell")
      ("{" table-shorten-cell "shorten cell")
      ("}" table-heighten-cell "heighten cell"))
     "Table justify"
     (("c" table-justify-cell "justify cell")
      ("C" table-justify-column "justify column")
      ("r" table-justfy-row "justify row"))
     "Table insert"
     (("i" table-insert-row "insert row")
      ("I" table-insert-column "insert column"))
     "Table delete"
     (("d" table-kill-row "delete row")
      ("D" table-kill-column "delete column"))
     "Table move"
     (("J" table-row-down "row down")
      ("K" table-row-up "row up")
      ("H" table-column-left "column left")
      ("L" table-column-right "column right"))))
#+end_src

** hydra-elisp
#+begin_src emacs-lisp
  (:hydra episteme-hydra-elisp (:color blue :major-mode emacs-lisp-mode)
    ("Execute"
     (("d" eval-defun "defun")
      ("b" eval-current-buffer "buffer")
      ("r" eval-region "region"))
     "Debug"
     (("D" edebug-defun "defun")
      ("a" edebug-all-defs "all definitions" :color red)
      ("A" edebug-all-forms "all forms" :color red)
      ("x" macrostep-expand "expand macro"))))
#+end_src

** hydra-org
*** hydra-org-goto-first-sibling
#+begin_src emacs-lisp
  (defun hydra-org-goto-first-sibling () (interactive)
         (org-backward-heading-same-level 99999999))
#+end_src

*** hydra-org-goto-last-sibling
#+begin_src emacs-lisp
  (defun hydra-org-goto-last-sibling () (interactive)
         (org-forward-heading-same-level 99999999))
#+end_src

*** hydra-org-parent-level
#+begin_src emacs-lisp
  (defun hydra-org-parent-level ()
    (interactive)
    (let ((o-point (point)))
      (if (save-excursion
            (beginning-of-line)
            (looking-at org-heading-regexp))
          (progn
            (call-interactively 'outline-up-heading)
            (org-cycle-internal-local))
        (progn
          (call-interactively 'org-previous-visible-heading)
          (org-cycle-internal-local)))
      (when (and (/= o-point (point))
                 org-tidy-p)
        (call-interactively 'hydra-org-tidy))))

 #+end_src

*** hydra-org-child-level
#+begin_src emacs-lisp
  (defun hydra-org-child-level ()
    (interactive)
    (org-show-entry)
    (org-show-children)
    (when (not (org-goto-first-child))
      (when (save-excursion
              (beginning-of-line)
              (looking-at org-heading-regexp))
        (next-line))))
#+end_src

*** hydra-org
 #+begin_src emacs-lisp
   (:hydra episteme-hydra-org (:color red :major-mode org-mode)
     ("Shift"
      (("K" org-move-subtree-up "up")
       ("J" org-move-subtree-down "down")
       ("h" org-promote-subtree "promote")
       ("l" org-demote-subtree "demote"))
      "Travel"
      (("p" org-backward-heading-same-level "backward")
       ("n" org-forward-heading-same-level "forward")
       ("j" hydra-org-child-level "to child")
       ("k" hydra-org-parent-level "to parent")
       ("a" hydra-org-goto-first-sibling "first sibling")
       ("e" hydra-org-goto-last-sibling "last sibling"))
      "Perform"
      (("t" (org-babel-tangle) "tangle" :color blue)
       ("e" (org-html-export-to-html) "export" :color blue)
       ("b" helm-org-in-buffer-headings "browse")
       ("r" (lambda () (interactive)
              (helm-org-rifle-current-buffer)
              (org-cycle)
              (org-cycle)) "rifle")
       ("w" helm-org-walk "walk")
       ("v" avy-org-goto-heading-timer "avy")
       ("L" org-toggle-link-display "toggle links"))))
#+end_src

* startup
#+begin_src emacs-lisp
  (call-interactively 'episteme:dashboard)
#+end_src
